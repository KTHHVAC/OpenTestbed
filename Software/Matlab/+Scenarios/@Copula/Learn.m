function Learn( tCopula )
	%
	% learn the marginal CDFs
	tCopula.LearnMarginalCDFs();
	%
	% rank the samples
	aafRankedSamples = tCopula.RankSamples( tCopula.aafOriginalSamples );
	%
	% compute the copula
	tCopula.aafCopula = copulafit(tCopula.strCopulaFamily, aafRankedSamples);
	%
	% consistency checks
	switch( tCopula.strCopulaFamily )
		%
		case 'Gaussian'
			% in this case the copula is actually a correlation matrix, and
			% it must be symmetric and positive definite
			if( tCopula.aafCopula ~= tCopula.aafCopula' )
				%
				error('copulafit() returned a non-symmetric correlation matrix');
				%
			end;%
			%
			% check for PD-ness: use chol(), that is more computationally efficient
			% than checking the single eigenvalues
			[ aafCholeskyDecomposition, bIsTheArgumentNotPositiveDefinite ] =	...
				chol(tCopula.aafCopula);
			%
			if( bIsTheArgumentNotPositiveDefinite )
				%
				warning('copulafit() returned a non positive definite correlation matrix. Now we''ll fix it.');
				%
				tCopula.aafCopula = ...
					EstimationAlgorithms.MakeSymmetricMatrixPositiveDefinite( tCopula.aafCopula );
				%
				tCopula.aafCopula = ...
					EstimationAlgorithms.MakePositiveDefiniteMatrixACorrelationMatrix( tCopula.aafCopula );
				%
			end;%
			%
			[ aafCholeskyDecomposition, bIsTheArgumentNotPositiveDefinite ] =	...
				chol(tCopula.aafCopula);
			%
			if( bIsTheArgumentNotPositiveDefinite )
				%
				eig(tCopula.aafCopula)
				bIsTheArgumentNotPositiveDefinite
				error('Fixing did not work.');
				%
			end;%
		%
		otherwise
			error('wrong copula type');
		%
	end;% switch on the copula type
	%
	% learn the normalization factor
	tCopula.LearnPDFEvaluationsNormalizationFactor();
	%
	% compute the expected sample
	tCopula.ComputeExpectedSample();
	%
	% DEBUG
	if( tCopula.bPrintDebugInformation )
		%
		fprintf('copula %d: just finished the learning step\n', tCopula.iLabel);
%		tCopula.aafCopula
		%
	end;%
	%
end %

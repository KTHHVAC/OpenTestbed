% algorithm:
%
% - take all the precomputed samples
% - create the subset of samples that satisfy the initial condition
% - if this subset is empty then put it equal to all the precomputed samples
% - extract from this subset
%
% Note: if the initial condition is not in the domain of the copula then
% take as initial condition the element of the domain that is the closest
% one in Euclidean sense
%
function aafSamples =				...
			Extract(				...
				tCopula,			...
				iNumberOfSamples,	... optional
				fInitialCondition	) % optional
	%
	switch( nargin )
		%
		case 1
			iNumberOfSamples	= 10;
			fInitialCondition	= [];
		%
		case 2
			fInitialCondition	= [];
		%
		case 3
			% do nothing
		%
		otherwise
			error('wrong number of arguments in Extract()');
		%
	end;%
	%
	if( numel(fInitialCondition) == 0 )
		%
		% in this case consider as plausible every precomputed sample
		aafPrecomputedSamples = tCopula.aafGeneratedSamples;
		%
	else%
		%
		% modify the initial condition so that it is actually in the
		% domain of the copula
		fInitialCondition = Signal.FindClosestElement( tCopula.atMarginalCDFs(1).afDomain, fInitialCondition );
		%
		% compute which sample start with the right initial condition
		aiIndexes = ( tCopula.aafGeneratedSamples(:, 1) == fInitialCondition );
		%
		% thus consider only this subset
		aafPrecomputedSamples = tCopula.aafGeneratedSamples( aiIndexes, : );
		%
		% in case the subset is empty override the initial condition
		if( numel(aafPrecomputedSamples) == 0 )
			%
			aafPrecomputedSamples = tCopula.aafGeneratedSamples;
			%
		end;%
		%
	end;%
	%
	% extract the indexes of the samples to be returned
	aiSamplesIndexes = randi(	[1, numel( aafPrecomputedSamples(:, 1) )], ...
								iNumberOfSamples, 1 );
	%
	% return the corresponding samples
	aafSamples = aafPrecomputedSamples( aiSamplesIndexes', : );
	%
end % function


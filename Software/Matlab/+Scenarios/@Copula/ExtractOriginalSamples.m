% algorithm
%
% - if the JD for the selection of the period are not set (or are not meaningful)
%   then put them to either the starting or ending JD (so that they do not harm)
%
function aafSamples =										...
			ExtractOriginalSamples(							...
				tCopula,									...
				iNumberOfSamples,							...
				fInitialCondition,							... optional
				fConsiderOriginalSamplesFromJulianDate,		... optional, but may be -1
				fConsiderOriginalSamplesUpToJulianDate		) % optional, but may be -1
	%
	% manage the number of arguments
	switch( nargin )
		%
		case 1
			iNumberOfSamples	= 10;
			fInitialCondition	= NaN;
			fConsiderOriginalSamplesFromJulianDate = tCopula.afOriginalSamplesJulianDates(1);
			fConsiderOriginalSamplesUpToJulianDate = tCopula.afOriginalSamplesJulianDates(end);
		%
		case 2
			fInitialCondition = NaN;
			fConsiderOriginalSamplesFromJulianDate = tCopula.afOriginalSamplesJulianDates(1);
			fConsiderOriginalSamplesUpToJulianDate = tCopula.afOriginalSamplesJulianDates(end);
		%
		case 3
			fConsiderOriginalSamplesFromJulianDate = tCopula.afOriginalSamplesJulianDates(1);
			fConsiderOriginalSamplesUpToJulianDate = tCopula.afOriginalSamplesJulianDates(end);
		%
		case 4
			fConsiderOriginalSamplesUpToJulianDate = tCopula.afOriginalSamplesJulianDates(end);
		%
		case 5
			% do nothing
		%
		otherwise
			error('wrong number of arguments in ExtractOriginalSamples');
		%
	end;%
	%
	% manage the case where the arguments are -1
	if( fConsiderOriginalSamplesFromJulianDate == -1 )
		%
		fConsiderOriginalSamplesFromJulianDate = tCopula.afOriginalSamplesJulianDates(1);
		%
	end;%
	if( fConsiderOriginalSamplesUpToJulianDate == -1 )
		%
		fConsiderOriginalSamplesUpToJulianDate = tCopula.afOriginalSamplesJulianDates(end);
		%
	end;%
	%
	%
	% remove the samples that are outside of the desired JD interval
	%
	% find the indexes
	if( tCopula.afOriginalSamplesJulianDates(end) < fConsiderOriginalSamplesFromJulianDate )
		%
		iStartingIndex = 1;
		%
	else%
		%
		iStartingIndex	= find( tCopula.afOriginalSamplesJulianDates >= fConsiderOriginalSamplesFromJulianDate, 1, 'first');
		%
	end;%
	%
	if( tCopula.afOriginalSamplesJulianDates(1) > fConsiderOriginalSamplesUpToJulianDate )
		%
		iEndingIndex = numel(tCopula.afOriginalSamplesJulianDates);
		%
	else%
		%
		iEndingIndex = find( tCopula.afOriginalSamplesJulianDates <= fConsiderOriginalSamplesUpToJulianDate, 1, 'last');
		%
	end;%
	%
	if( fConsiderOriginalSamplesUpToJulianDate < fConsiderOriginalSamplesUpToJulianDate )
		%
		iStartingIndex	= 1;
		iEndingIndex	= numel(tCopula.afOriginalSamplesJulianDates);
		%
	end;%
	%
	%
	% DEBUG
% 	Time.JulianDateToString( tCopula.afOriginalSamplesJulianDates(end) )
% 	Time.JulianDateToString( fConsiderOriginalSamplesFromJulianDate )
% 	iStartingIndex
% 	%
% 	Time.JulianDateToString( tCopula.afOriginalSamplesJulianDates(1) )
% 	Time.JulianDateToString( fConsiderOriginalSamplesUpToJulianDate )
% 	iEndingIndex
	%
	%
	% select between the indexes
	aafSamplesInTheDesiredJDInterval = tCopula.aafOriginalSamples( iStartingIndex : iEndingIndex, : );
	%
	%
	if( numel(fInitialCondition) == 0 )
		%
 		fInitialCondition = NaN;
		%
	end;%
	%
	if( isnan(fInitialCondition) )
		%
		% in this case consider as plausible every precomputed sample
		aafPrecomputedSamples = aafSamplesInTheDesiredJDInterval;
		%
	else%
		%
		% modify the initial condition so that it is actually in the
		% domain of the copula
		fInitialCondition = Signal.FindClosestElement( tCopula.atMarginalCDFs(1).afDomain, fInitialCondition );
		%
		% compute which sample start with the right initial condition
		aiIndexes = ( aafSamplesInTheDesiredJDInterval(:, 1) == fInitialCondition );
		%
		% thus consider only this subset
		aafPrecomputedSamples = aafSamplesInTheDesiredJDInterval( aiIndexes, : );
		%
		% in case the subset is empty override the initial condition
		if( numel(aafPrecomputedSamples) == 0 )
			%
			aafPrecomputedSamples = aafSamplesInTheDesiredJDInterval;
			%
		end;%
		%
	end;%
	%
	% extract the indexes of the samples to be returned
	aiSamplesIndexes = randi(	[1, numel( aafPrecomputedSamples(:, 1) )], ...
								iNumberOfSamples, 1 );
	%
	% return the corresponding samples
	aafSamples = aafPrecomputedSamples( aiSamplesIndexes', : );
	%
end % function


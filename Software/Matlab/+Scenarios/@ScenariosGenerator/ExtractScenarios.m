% usage:
%
% aafScenarios =					...
% 	tGenerator.ExtractScenarios(	...
% 		fInitialJulianDate,			...
% 		iNumberOfScenarios,			...
% 		fInitialCondition			);% [optional]
%
% inputs:
%
% - fInitialJulianDate    needed to understand if the generation follows the
%                         pattern of the morning / afternoon / night, etc.
%
% - iNumberOfScenarios    how many scenarios one wants to be returned
%
% - fInitialCondition     OPTIONAL, if given it returns only scenarios that
%                         start with that given initial condition. If the
%                         marginals does not admit that initial condition (i.e.,
%                         that condition has never been seen when training the
%                         generator) then the scenarios returned will violate
%                         that initial condition
%
% - fToleranceOnIn.C.     OPTIONAL, if given it broadens the action of the
%                         previous initial condition, making it work as a set
%                         of values
%
% outputs:
%
% - aafScenarios          matrix, whose rows are scenarios. Thus the matrix has
%                         iNumberOfScenarios rows and a number of columns that
%                         depends on how the generator has been set at the
%                         beginning
%
function aafScenarios =							...
			ExtractScenarios(					...
				tGenerator,						...
				fInitialJulianDate,				... optional
				iNumberOfScenarios,				... optional
				fInitialCondition,				... optional
				fToleranceOnTheInitialCondition	) % optional
	%
	try %
		%
		if( tGenerator.bPrintDebugInformation )
			%
			fprintf('Entering ExtractScenarios()\n');
			%
		end;%
		%
		if( nargin == 1 )
			%
			fInitialJulianDate = Time.GetCurrentJulianDate();
			%
		end;%
		%
		iPeriod = tGenerator.JulianDateToPeriod( fInitialJulianDate );
		%
		switch( nargin )
			%
            case {1, 2}
				aafScenarios = tGenerator.atCopulas(iPeriod).Extract();
			%
            case 3
				aafScenarios = tGenerator.atCopulas(iPeriod).Extract(iNumberOfScenarios);
			%
            case 4
				aafScenarios = tGenerator.atCopulas(iPeriod).Extract(iNumberOfScenarios, fInitialCondition);
			%
            case 5
				aafScenarios = tGenerator.atCopulas(iPeriod).Extract(iNumberOfScenarios, fInitialCondition, fToleranceOnTheInitialCondition);
			%
			otherwise
				error('wrong number of parameters in ExtractScenarios')
			%
		end;%
		%
		%
		if( tGenerator.bPrintDebugInformation )
			%
			fprintf('Exiting ExtractScenarios()\n');
			%
		end;%
		%
	catch exception
		%
		disp( exception.message );
		warning('Unable to extract the Scenarios');
		%
	end % try

	%
	% Algorithm:
	% - get the julian dates of the scenarios horizon
	% - divide the scenarios horizon in time-domains, i.e., which copula is
	%   associated to which slice of the time
	% - start with the correct first copula
	% - then pass to the next copulas imposing the initial condition
	%
% 	% ----------------------------------------------------------------------------
% 	% get the scenarios horizon
% 	afScenariosJulianDates = 										...
% 				fInitialJulianDate									... 
% 			+														...	
% 					(1:tGenerator.iForecastingHorizonInSamples)		...
% 				*	tGenerator.fSamplingTimeInSeconds				...
% 			   	*	Time.GetJulianSecond();
% 	%
% 	%
% 	% ----------------------------------------------------------------------------
% 	% divide the horizon in periods
% 	aiPeriods 					= tGenerator.JulianDateToPeriod( afScenariosJulianDates ); % e.g., 3333444445555566666
% 	aiPeriodsJumpsIndexes 		= [1, find(diff(aiPeriods)), numel(aiPeriods)]; % thus we force the first and the last sample indexes to be considered a jump
% 	iNumberOfDifferentPeriods	= numel(aiPeriodsJumpsIndexes) - 1;
% 	%
% 	% ----------------------------------------------------------------------------
% 	for iCurrentPeriodIndex = 1:iNumberOfDifferentPeriods;
% 		%
% 		iCurrentPeriodInitialSample = aiPeriodsJumpsIndexes(iCurrentPeriodIndex);
% 		iCurrentPeriodFinalSample 	= aiPeriodsJumpsIndexes(iCurrentPeriodIndex + 1);
% 		iCurrentPeriod 				= aiPeriods(iCurrentPeriodIndex);
% 		%
% 		% because of the forcing of the initial conditions, it is necessary to
% 		% generate one scenario per time
% 		for iScenario = 1:iNumberOfScenarios;
% 			%
% 			% in case, generate a fake initial condition
% 			if( iCurrentPeriodInitialSample == 1  )
% 				%
% 				if( nargin < 4 )
% 					% 
% 					fInitialCondition = [];
% 					%
% 				end;%
% 				%
% 			else%
% 				%
% 				% case "not the initial period", the initial condition must
% 				% always be indicated -- notice that we go looking for the
% 				% sample inside the new period!
% 				fInitialCondition = aafScenarios( iScenario, iCurrentPeriodInitialSample );
% 				%
% 			end;%
% 			%
% 			% generate the scenarios of the current copula
% 			afCurrentScenario = tGenerator.atCopulas(iCurrentPeriod).Extract(1, fInitialCondition);
% 			%
% 			% attach it to the global output
% 			aafScenarios( iScenario, iCurrentPeriodInitialSample:iCurrentPeriodFinalSample ) =	...
% 				afCurrentScenario( 1:(iCurrentPeriodFinalSample - iCurrentPeriodInitialSample + 1) ); 
% 			%
% 			% DEBUG
% % 			fprintf('Current period: from sample %d to sample %d\n', iCurrentPeriodInitialSample, iCurrentPeriodFinalSample );
% 			%
% 		end;% cycle on the single scenarios
% 		%
% 	end;% cycle on the various periods
% 	%
end % function


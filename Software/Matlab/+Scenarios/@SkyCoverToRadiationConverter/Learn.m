% algorithm
%
% - extract the signals from the databases
% - compute the point-evaluation functions
% - solve the regularization problem
%
function Learn(									...
			tConverter,							...
			strSkyCoverDatasetFilepath,			...
			strRadiationDatasetFilepath		)
	%
	% parameters settings
	strRegularizationKernelKind		= 'Laplacian';
	fRegularizationKernelScale		= 100;
	fRegularizationParameter		= 1;
	afSkyCoverSignalDomain			= 0:10:100;
	afMaximalRadiationSignalDomain	= 0:50:500;
	%
	%
	% ------------------------------------------------------
	% extract the signals
	fprintf('extracting the signals\n');
	tSkyCoverSignal				= tConverter.GetSkyCoverSignal(strSkyCoverDatasetFilepath);
	tMeasuredRadiationSignal	= tConverter.GetMeasuredRadiationSignal(strRadiationDatasetFilepath);
	%
	% find the intersection of the time spans of the two signals
	fInitialJulianDate	= max( tSkyCoverSignal.afTimes(1),		tMeasuredRadiationSignal.afTimes(1)		); 
	fFinalJulianDate	= min( tSkyCoverSignal.afTimes(end),	tMeasuredRadiationSignal.afTimes(end)	); 
	%
	% construct the julian dates of the resampled signals
	afJulianDates =		fInitialJulianDate												...
					:	tConverter.fSamplingPeriodInSeconds * Time.GetJulianSecond()	...
					:	fFinalJulianDate;
	%
	% get the maximal radiation signal
	tMaximalRadiationSignal	= tConverter.GetMaximalRadiationSignal( afJulianDates );
	%
	% extract the samples
	afSkyCoverSamples			= tSkyCoverSignal.ExtractSamplesAt( afJulianDates );
	afMaximalRadiationSamples	= tMaximalRadiationSignal.ExtractSamplesAt( afJulianDates );
	afMeasuredRadiationSamples	= tMeasuredRadiationSignal.ExtractSamplesAt( afJulianDates );
	%
	%
	% DEBUG
% 	figure(1)
% 	plot(afSkyCoverSamples);
% 	figure(2)
% 	plot(afMeasuredRadiationSamples);
% 	figure(3)
% 	plot(afMaximalRadiationSamples);
% 	tEmpiricalFunction = BidimensionalSignal();
% 	tEmpiricalFunction.Insert(			...
% 		afMeasuredRadiationSamples,		...
% 		afSkyCoverSamples,				...
% 		afMaximalRadiationSamples		);
% 	tEmpiricalFunction.Plot();
% 	pause
	%
	%
	%
	% ------------------------------------------------------
	% solve the regularization problem
	fprintf('solving the regularization problem\n');
	%
	% get the sampled kernel
	aafSampledKernel = EstimationAlgorithms.GetSampledBidimensionalLaplacianKernelAt(	...
						afSkyCoverSamples,												...
						afMeasuredRadiationSamples,										...
						fRegularizationKernelScale										);
	%
	% compute the coefficients
	afCoefficients =															...
		inv																		...
		(																		...
				aafSampledKernel												...
			+	fRegularizationParameter * eye( size( aafSampledKernel ) )		...
		)																		...
		*																		...
		afMaximalRadiationSamples;
	%
	%
	%
	% ------------------------------------------------------
	% construct the actual regression map
	fprintf('constructing the regression map\n');
	%
	% storage allocation
	tConverter.tBidimensionalMap = BidimensionalSignal();
	%
	% cycle on the samples of the dataset
	for iSkyCoverSampleIndex			= 1:numel(afSkyCoverSignalDomain);
	for iMaximalRadiationSampleIndex	= 1:numel(afMaximalRadiationSignalDomain);
		%
		% for readability we indicate the triplet in tBidimensionalMap as (x,y,z)
		fX = afSkyCoverSignalDomain(iSkyCoverSampleIndex);
		fY = afMaximalRadiationSignalDomain(iMaximalRadiationSampleIndex);
		%
		% initialization
		fZ = 0;
		%
		% cycle on the samples of the dataset
		for iSample = 1:numel(afSkyCoverSamples);
			%
			% for readability
			fSampleX = afSkyCoverSamples(iSample);
			fSampleY = afMaximalRadiationSamples(iSample);
			%
			fZ =	fZ																		...
				+	(		afCoefficients(iSample)											...
						*	EstimationAlgorithms.EvaluateBidimensionalLaplacianKernelAt(	...
								[fX, fY],													...
								[fSampleX, fSampleY],										...
								fRegularizationKernelScale									));
			%
		end;% cycle on the samples of the dataset
		%
		% insert the current value
		tConverter.tBidimensionalMap.Insert( fZ, fX, fY );
		%
		%
		% DEBUG
		if( ~mod(iSkyCoverSampleIndex, 5) )
			fprintf('.');
		end;%
		%
	end;%
	end;% cycle on the samples
	% 
	%
	%
	% DEBUG
% 	tSkyCoverSignal.Plot();
% 	tMeasuredRadiationSignal.Plot();
% 	tMaximalRadiationSignal.Plot();
% 	Time.JulianDateToString( afJulianDates )
	%
end % function


% algorithm
%
% - construct the bidimensional signal from the database
% - solve the regularization problem
%
%
% source for the measured solar radiation
% http://slb.nu/cgi-bin/airweb.gifgraphic.cgi?format=txt&zmacro=lvf/met/hour/big//lvf-globstralning_big.ic&from=130801&to=131019&path=/usr/airviro/data/sthlm/&lang=swe&rsrc=Meteorologi.3.MainPage&st=lvf&regionPath= 
%
function Learn(								...
			tConverter,						...
			strSkyCoverDatasetFilepath,		...
			strRadiationDatasetFilepath		)
	%
	%
	% ------------------------------------------------------
	% extract the signals
	fprintf('extracting the signals\n');
	tSkyCoverSignal				= tConverter.GetSkyCoverSignal(strSkyCoverDatasetFilepath);
	tMeasuredRadiationSignal	= tConverter.GetMeasuredRadiationSignal(strRadiationDatasetFilepath);
	%
	% DEBUG
% 	tSkyCoverSignal.Plot();
% 	tMeasuredRadiationSignal.Plot();
% 	pause
	%
	% find the intersection of the time spans of the two signals
	fInitialJulianDate	= max( tSkyCoverSignal.afTimes(1),		tMeasuredRadiationSignal.afTimes(1)		); 
	fFinalJulianDate	= min( tSkyCoverSignal.afTimes(end),	tMeasuredRadiationSignal.afTimes(end)	); 
	%
	% DEBUG
	fprintf('Starting date: %s\nEnding date:   %s\n',		...
			Time.JulianDateToString(fInitialJulianDate){1},	...
		   	Time.JulianDateToString(fFinalJulianDate){1}	);
	%
	% construct the julian dates of the resampled signals
	afJulianDates =		fInitialJulianDate												...
					:	tConverter.fSamplingPeriodInSeconds * Time.GetJulianSecond()	...
					:	fFinalJulianDate;
	%
	% get the maximal radiation signal
	tMaximalRadiationSignal	= tConverter.GetMaximalRadiationSignal( afJulianDates );
	%
	% extract the samples
	afSkyCoverSamples			= tSkyCoverSignal.ExtractSamplesAt( afJulianDates );
	afMaximalRadiationSamples	= tMaximalRadiationSignal.ExtractSamplesAt( afJulianDates )
	afMeasuredRadiationSamples	= tMeasuredRadiationSignal.ExtractSamplesAt( afJulianDates );
	%
	% check if there are some NaNs
	if( sum( isnan( afSkyCoverSamples ) ) )
		%
		warning('the sky cover samples contain some NaNs!!');
		%
	end;%
	if( sum( isnan(	afMeasuredRadiationSamples ) ) )
		%
		warning('the measured radiation samples contain some NaNs!!');
		%
	end;%
	if( sum( isnan( afMaximalRadiationSamples ) ) )
		%
		warning('the maximal radiation samples contain some NaNs!!');
		%
	end;%
	%
	% learn the normalization factors
	tConverter.fSkyCoverNormalizationFactor				= max(afSkyCoverSamples);
	tConverter.fMeasuredRadiationNormalizationFactor	= max(afMeasuredRadiationSamples);
	tConverter.fMaximalRadiationNormalizationFactor		= max(afMaximalRadiationSamples);
	%
	% normalize the data
	afSkyCoverSamples			= afSkyCoverSamples				./ tConverter.fSkyCoverNormalizationFactor;
	afMeasuredRadiationSamples	= afMeasuredRadiationSamples	./ tConverter.fMeasuredRadiationNormalizationFactor;
	afMaximalRadiationSamples	= afMaximalRadiationSamples		./ tConverter.fMaximalRadiationNormalizationFactor;
	%
	% construct the bidimensional function
	tConverter.tEmpiricalMap = BidimensionalSignal();
	tConverter.tEmpiricalMap.Insert(	...
		afMeasuredRadiationSamples,		...
		afSkyCoverSamples,				...
		afMaximalRadiationSamples		);
	%
	% ------------------------------------------------------
	% solve the regularization problem
	fprintf('solving the regularization problem\n');
	%
	tConverter.tRegularizedMap =								...
		EstimationAlgorithms.RegularizeBidimensionalSignal(		...
			tConverter.tEmpiricalMap,							...
			@EstimationAlgorithms.EvaluateGaussianKernelAt,		...
			10000,												...
			10,													...
			true												);
	%
	%
	% DEBUG
	tSkyCoverSignal.Plot();
	tMeasuredRadiationSignal.Plot();
	tMaximalRadiationSignal.Plot();
	tConverter.tEmpiricalMap.Plot();
	tConverter.tRegularizedMap.Plot();
% 	Time.JulianDateToString( afJulianDates )
	%
end % function


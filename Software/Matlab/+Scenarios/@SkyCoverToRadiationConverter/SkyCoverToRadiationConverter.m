% SinElevSun := COS(Lat*DEG_2_RAD)*COS(Declination)*COS(Omega)
%                + SIN(Lat*DEG_2_RAD)*SIN(Declination);
% 
%    ElevSun := ASIN(SinElevSun)*RAD_2_DEG;
% 
% /* Azimuth angle of Sun, counted positive westward from South.
%    It will thus be negative if solar time is less than 12.
%    Cf ASHRAE Fundamentals Chapter 27 */
% 
%    CosAzimSun = (SinElevSun*SIN(Lat*DEG_2_RAD) - SIN(Declination))
%                  /(COS(ElevSun*DEG_2_RAD)*COS(Lat*DEG_2_RAD));
% 
%    AzimutSun := IF CosAzimSun < -1 THEN
%                  180
%                ELSE_IF CosAzimSun > 1 THEN
%                  0
%                ELSE_IF (SolarTime < 12) THEN
%                  (-ACOS(CosAzimSun)*RAD_2_DEG)
%                ELSE
%                  ACOS(CosAzimSun)*RAD_2_DEG
%                END_IF;
%
classdef SkyCoverToRadiationConverter < handle
	%
	% ---------------------------------------------------------------------
	properties
		%
		% Look up table of the maximal solar radiations, build in the constructor
		aiHoursInAYear;
		afMaximalSolarRadiation; % watts / m^2
		%
		fLatitude;
		fLongitude;
		iTimeZone;
		iNumberOfSamplesPerHour;
		%
		tWall;
		%
		% parameters
		tExtraterrestrialRadiationSignal;
		%
	end %
	%
	%
	% ---------------------------------------------------------------------
	methods
		%
		% standard constructor
		function tConverter = SkyCoverToRadiationConverter()
			%
			% Days used for the assessment of the constants ET,B and C
			af21stsOfTheVariousMonthsInJulianDates =	...
				[21 52 80 111 141 172 202 233 264 294 325 355] * Time.GetJulianDay() + Time.GetCurrentJulianYear();
			%
			% DEBUG
			Time.JulianDateToString(af21stsOfTheVariousMonthsInJulianDates) % TODO understand there is an error
			%
			tExtraterrestrialRadiationSignal = Signal();
			tExtraterrestrialRadiationSignal.Insert(							...
				af21stsOfTheVariousMonthsInJulianDates,							...
				[1396 1384 1364 1341 1321 1310 1311 1324 1345 1367 1388 1398]	);
			%



C		= [0.058 0.06 0.071 0.097 0.121 0.134 0.136 0.122 0.092 0.073 0.063 0.057]';	% Coefficient used for the calculation of C2
RAD_2_DEG     = 360/(2*pi);																	% Conversion factor, radians to degrees
DEG_2_RAD     = (2*pi)/360;																	% Conversion factor, degrees to radians
rho_g		= 0.1;																			% Ground reflectivity used for IRefl, [-]
i			= 1;																			% Counter initialization 

for g = 1:365
	
	C2		= interp1(day_21,C,g);															% Coefficient used to assess IDif

		% Daily values
declination		= 23.45*sin(2*pi*(284+g)/365);												% Sun declination, [deg]
declination_rad = declination*DEG_2_RAD;														% Sun declination, [rad]
w			= 2 * pi * g / 365;																% Time equation "e" variable [rad]
e			= (0.42 * cos(w) - 3.23 * cos(2 * w)- 0.09 * cos(3 * w)...
			-7.35 * sin(w)- 9.39 * sin(2 * w)- 0.34 * sin(3 * w))/60;						% Time equation, [degrees]

		% Hourly values
hour			= [1:1/hourRes:24]';														% Hour vector, [h]
hour_angle		= 15 .*(hour-12)-(0.25 .*(e - 4*(long-timeZone*15)));						% Hour angle, [deg] 
size_hour_angle = size(hour_angle);															% Help variable
		
sin_beta_rad	= cos(hour_angle*DEG_2_RAD).*...
				cos(declination_rad).*cos(lat*DEG_2_RAD)+...
				sin(declination_rad).*sin(lat*DEG_2_RAD);
beta_rad		= asin(sin_beta_rad);														% Solar elevation,[rad]
cos_phi			= (sin(declination_rad).*cos(lat*DEG_2_RAD)-...
				cos(hour_angle*DEG_2_RAD).*...
				cos(declination_rad).*sin(lat*DEG_2_RAD))...
				./cos(beta_rad);															% Solar azimuth cosinus

phi_rad			= (hour_angle<=0).*acos(cos_phi) +...
				(1-(hour_angle<=0)).*(2*pi-acos(cos_phi));									% Solar azimuth,[rad]
phi				= phi_rad*RAD_2_DEG;															% Solar azimuth,[deg]

gamma			= abs(phi_rad*RAD_2_DEG-psi);													% Wall solar azimuth, (angle measured in the horizontal plane between the projection of thh sun
																							% rays on the plane and the normal to the vertical surface ) [deg]
cos_theta		= cos(beta_rad).*cos(gamma*DEG_2_RAD).*sin(alpha*DEG_2_RAD)+ ...
				sin(beta_rad).*cos(alpha*DEG_2_RAD);
theta_rad		= acos(cos_theta);															% Incidence angle [rad]
theta			= theta_rad*RAD_2_DEG;														% Incidence angle [deg]

		% Radiation data interpolation
Rad_Dir_interp	= interp1(test_h_matrix(:,g),Rad_Dir(:,g),hour,'pchip');					% Direct radiation on a surface perpendicular to sun rays,[W,m2]
Rad_Diff_interp = interp1(test_h_matrix(:,g),Rad_Diff(:,g),hour,'pchip');					% Diffuse radiation on a surface perpendicular to sun rays,[W,m2] - not used in this version of the program

		% Direct radiation on the considered surface, [W/m2]
IDirN		= Rad_Dir_interp;						% Direct radiation on a surface perpendicular to sun rays,[W/m2]
IDir		= IDirN.*cos(theta_rad).*...			% expression
			(beta_rad*RAD_2_DEG > 0)...				% condition 1: if beta < 0 the sun is behind the horizon
			.*(theta<=90);							% condition 2:if theta > 90 then sun rays are behind the surface

		% Diffuse radiation on the considered surface, [W/m2]
IDif		= IDirN.*(1+cos(alpha*DEG_2_RAD))/2.*C2.*...
			(beta_rad*RAD_2_DEG > 0);					% condition 1: if beta < 0 the sun is behind the horizon

		% Reflected radiation on the considered surface, [W/m2]
IRefl	= IDirN.*rho_g.*((1-cos(alpha*DEG_2_RAD))/2)...
		.*(sin(beta_rad)+C2)...
		.*(beta_rad*RAD_2_DEG > 0);					% condition 1: if beta < 0 the sun is behind the horizon
		% Total radiation on the considered surface, [W/m2]
ITot	= IDir + IDif+ IRefl; 

end % cycle on the days

		end % standard constructor
		%
	end %
	%
	%
	% ---------------------------------------------------------------------
	methods (Static = true)
		%
		%
	end %
	%
end % classdef


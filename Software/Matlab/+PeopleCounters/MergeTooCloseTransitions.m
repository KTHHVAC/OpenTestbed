% algorithm
%
% for each couple of consecutive rows check if the ending of the first and the
% beginning of the second are too close. In case, merge (implies diminishing 
% the dimension of the matrix of 1 row)
%
% for implementative purposes it is better to start from the last row
%
function aaiMergedTransitions = MergeTooCloseTransitions( aaiTransitions, iThreshold )
	%
	if( numel(aaiTransitions) == 0 )
		%
		% manage the case where there are no transitions
		aaiMergedTransitions = [];
		return;
		%
	end;%
	%
	% for readability
	iOriginalNumberOfTransitions = numel( aaiTransitions(:, 1) );
	%
	% initialization
	aaiMergedTransitions = aaiTransitions;
	%
	iNumberOfMergings = 0;
	%
	% cycle on the various couples of transitions
	for iTransition = iOriginalNumberOfTransitions:-1:2;
		%
		if(		abs( aaiMergedTransitions(iTransition-1, 2) - aaiMergedTransitions(iTransition, 1) )	...
			<	iThreshold																				)
			%
			aaiMergedTransitions	=	...
				[						...
					... all the rows before the current couple
					aaiMergedTransitions( 1:iTransition-2 , : );	...
					...
					... then the merged couple
					[ aaiMergedTransitions( iTransition-1, 1 ), aaiMergedTransitions( iTransition, 2 ) ];	...
					...
					... then all the rows after the current couple
					aaiMergedTransitions( iTransition+1:end , : );	...
				];
			%
			iNumberOfMergings = iNumberOfMergings + 1;
			%
		end;%
		%
	end;%
	%
	% DEBUG
% 	disp( aaiTransitions );
% 	disp( aaiMergedTransitions );
% 	disp( iThreshold );
% 	disp( iNumberOfMergings );
% 	pause
	%
end % function


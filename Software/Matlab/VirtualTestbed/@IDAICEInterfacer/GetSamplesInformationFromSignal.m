function [	afValues,								...
			afHours		] =							...
				GetSamplesInformationFromSignal(	...
					tSignal,						...
					iNumberOfSamplesPerDay,			...
					bIsSignalPiecewiseConstant		)
	%
	% get some useful information
	iNumberOfDays = tSignal.GetNumberOfFullDays();
	aiMidnightsIndexes = tSignal.FindMidnights();
	%
	% allocation
	afValues	= [];
	afHours		= [];
	%
	% fill the information several data per day
	for iDay = 1:iNumberOfDays;
		%
		% for readability
		iStartingIndex = aiMidnightsIndexes(iDay);
		%
		if( iDay == iNumberOfDays )
			%
			iEndingIndex = aiMidnightsIndexes(iDay+1);
			%
		else%
			%
			iEndingIndex = aiMidnightsIndexes(iDay+1) - 1;
			%
		end;%
		%
		% sanity check on the number of samples
		iCurrentNumberOfSamples = iEndingIndex - iStartingIndex + 1;
		%
		if( iCurrentNumberOfSamples > iNumberOfSamplesPerDay )
			%
			error( 'wrong computation of the number of samples' );
			%
		end;%
		%
		% DEBUG
		fprintf('Day %d:\n', iDay);
		fprintf('current number of samples = %d\n', iCurrentNumberOfSamples);
		fprintf('number of samples per day = %d\n', iNumberOfSamplesPerDay);
		%
		% fill the information per sample
		for iSample = iStartingIndex:iEndingIndex;
			%
			afValues	= [ afValues; tSignal.afValues(iSample) ];
			afHours		= [ afHours;  Time.JulianDateToMinuteOfDay( tSignal.afTimes(iSample) ) ./ 60 ];
			%
		end;%
		%
		% pad with '24's
		for iSample = 1:(iNumberOfSamplesPerDay - iCurrentNumberOfSamples);
			%
			afValues	= [ afValues; tSignal.afValues(iEndingIndex) ];
			afHours		= [ afHours;  24 ];
			%
		end;%
		%
		% DEBUG
		fprintf('final size of the vectors = %d\n', numel(afValues));
		%
	end;% cycle on the days
	%
end % function



%
% MSG_RAW_512 omitted as output
% Generates Message Digest using SHA-512 algorithms
% Original code:
% http://www.mathworks.com/matlabcentral/fileexchange/31795-sha-algorithms-160224256384-512/content/sha/hash.m
% 
%              LEN  :: Enter Byte Oriented Message Length
%
%              ahcHexMessage  :: Enter the ahcHexMessage
%
%                      Limitation :: Matlab cannot read characters if MSG_LEN > 2^12
%                      ----- directly assign MSG to msg_str if MESG_LENGTH > 2^12
%
%
function ComputeHash(tConnection, iLen, achHexMessage)
	
	% ahcHexMessage to HEX string
	achAux = char();
	for i = 1 : iLen
		achAux =  strcat(achAux, tConnection.String2Hex( achHexMessage(i) ));
	end
	achHexMessage = achAux;

	% From now iLen is bit oriented
	iLen = iLen * 8;

	PAD_ZERO=64*2;
	MFACT=2;

	MSG_SZ_P_BLK=512*MFACT;
	MOD_SZ_BLK  = 448*MFACT; 

	KT64=[
		'428a2f98d728ae22'; '7137449123ef65cd'; 'b5c0fbcfec4d3b2f'; 'e9b5dba58189dbbc';
		'3956c25bf348b538'; '59f111f1b605d019'; '923f82a4af194f9b'; 'ab1c5ed5da6d8118';
		'd807aa98a3030242'; '12835b0145706fbe'; '243185be4ee4b28c'; '550c7dc3d5ffb4e2';
		'72be5d74f27b896f'; '80deb1fe3b1696b1'; '9bdc06a725c71235'; 'c19bf174cf692694';
		'e49b69c19ef14ad2'; 'efbe4786384f25e3'; '0fc19dc68b8cd5b5'; '240ca1cc77ac9c65';
		'2de92c6f592b0275'; '4a7484aa6ea6e483'; '5cb0a9dcbd41fbd4'; '76f988da831153b5';
		'983e5152ee66dfab'; 'a831c66d2db43210'; 'b00327c898fb213f'; 'bf597fc7beef0ee4';
		'c6e00bf33da88fc2'; 'd5a79147930aa725'; '06ca6351e003826f'; '142929670a0e6e70';
		'27b70a8546d22ffc'; '2e1b21385c26c926'; '4d2c6dfc5ac42aed'; '53380d139d95b3df';
		'650a73548baf63de'; '766a0abb3c77b2a8'; '81c2c92e47edaee6'; '92722c851482353b';
		'a2bfe8a14cf10364'; 'a81a664bbc423001'; 'c24b8b70d0f89791'; 'c76c51a30654be30';
		'd192e819d6ef5218'; 'd69906245565a910'; 'f40e35855771202a'; '106aa07032bbd1b8';
		'19a4c116b8d2d0c8'; '1e376c085141ab53'; '2748774cdf8eeb99'; '34b0bcb5e19b48a8';
		'391c0cb3c5c95a63'; '4ed8aa4ae3418acb'; '5b9cca4f7763e373'; '682e6ff3d6b2b8a3';
		'748f82ee5defb2fc'; '78a5636f43172f60'; '84c87814a1f0ab72'; '8cc702081a6439ec';
		'90befffa23631e28'; 'a4506cebde82bde9'; 'bef9a3f7b2c67915'; 'c67178f2e372532b';
		'ca273eceea26619c'; 'd186b8c721c0c207'; 'eada7dd6cde0eb1e'; 'f57d4f7fee6ed178';
		'06f067aa72176fba'; '0a637dc5a2c898a6'; '113f9804bef90dae'; '1b710b35131c471b';
		'28db77f523047d84'; '32caab7b40c72493'; '3c9ebe0a15c9bebc'; '431d67c49c100d4c';
		'4cc5d4becb3e42b6'; '597f299cfc657e2a'; '5fcb6fab3ad6faec'; '6c44198c4a475817'];
	HT64_512=[
	'6a09e667f3bcc908',
	'bb67ae8584caa73b',
	'3c6ef372fe94f82b',
	'a54ff53a5f1d36f1',
	'510e527fade682d1',
	'9b05688c2b3e6c1f',
	'1f83d9abfb41bd6b',
	'5be0cd19137e2179'
	];


	h0=tConnection.Convt2Bin64(HT64_512(1,:));
	h1=tConnection.Convt2Bin64(HT64_512(2,:));
	h2=tConnection.Convt2Bin64(HT64_512(3,:));
	h3=tConnection.Convt2Bin64(HT64_512(4,:));
	h4=tConnection.Convt2Bin64(HT64_512(5,:));
	h5=tConnection.Convt2Bin64(HT64_512(6,:));
	h6=tConnection.Convt2Bin64(HT64_512(7,:));
	h7=tConnection.Convt2Bin64(HT64_512(8,:));

	INV_M64=num2str(ones(64,1))';

	if iLen < 0 
		disp ('--- EXIT STATUS: Invalid ahcHexMessage LENGTH ENTERED---');
		disp (' RE-ENTER ahcHexMessage LENGTH, valid entries are 0-512' );
		disp ('---------------------------------');
		return 
	elseif(iLen>=1)
		%%%% Generate ahcHexMessage
		% 1. ONEs
		% 2. ZEROs
		% 3. ALTERNATING ONE-ZEROs
		mesg_d=((sign(rand(1,iLen)-0.5)) + 1) *0.5;
		%mesg_d = zeros(1,LEN); 
		%mesg_d = ones(1,LEN); 
		for u=1:iLen
		   mesg_d(u)=mod(u,2);
		end

	end 
	
	msg_str=char();

	for i=1:length(achHexMessage),
		msg_str      = strcat(msg_str,dec2bin(hex2dec(achHexMessage(i)),4));
	end

	msg_str=msg_str(1:iLen);



	%disp('RAW MSG(BITS) bfore preprocessed is');
	%disp(msg_str);

	MSG_RAW_512=char();
	raw_str=msg_str;


	blk_num = fix(length(msg_str)/(512*MFACT)) ;

	if(mod(length(msg_str),(512*MFACT)) ==0)
		blk_num = blk_num -1;
	end

	if(blk_num<0)
	   blk_num=0;
	end

	extnd=512*MFACT*(blk_num+1)-mod(length(msg_str),(512*MFACT));
	raw_str(end+1:end+extnd)= num2str(round(rand(1,extnd))')';

	for k=1:128*(blk_num+1)*MFACT
		MSG_RAW_512 = strcat(MSG_RAW_512,dec2hex(bin2dec(raw_str(4*(k-1)+1:4*k))));
	end

	 %% l+k+1 is congruent to 448 mod 512
	 %  FIND MINIMUM (0 or non-negetaive) K 
	 %  to satisfy
	 %
	 %          L+K+1 = 448 mod 512
	 %          L+K+1 is congruent to 448 
	 % solve mod(|(L+K+1) - 448 |, 512) = 0
	 %          

	msg_str(end+1) = '1';
	int_k=0;
	diff_k = abs(int_k+iLen+1-448*MFACT); 

	while(mod(diff_k,512*MFACT) ~=0)

		int_k  = int_k +1;
		diff_k = abs(int_k+iLen+1-448*MFACT); 
	end

	k=int_k;

	msg_str(end+1:end+k)='0'; %% Pad K-bits of '0's

	len_bits=dec2bin(iLen,PAD_ZERO); %% 64-bit representation of MSG_LEN

	MSG_2_PROC=cat(2,msg_str,len_bits); %%ahcHexMessage after PreProcess 

	MSG_PADDED=char();
	no_512_blk=length(MSG_2_PROC)/MSG_SZ_P_BLK;

	for k=1:(128*MFACT)*(no_512_blk)
		MSG_PADDED = strcat(MSG_PADDED,dec2hex(bin2dec(MSG_2_PROC(4*(k-1)+1:4*k))));
	end

	%% Check if Preprocess Happened correctly 
	%%disp('---+++');
	%%disp(MSG_2_PROC);
	%%disp('blk_num is');
	%%disp(blk_num);
	%%disp('---+++');
	MSG_L = length(MSG_2_PROC);
	N=0;
	if (mod(MSG_L,512*MFACT) == 0)
	   %%disp('ahcHexMessage PreProcessing is COrrect');
	   %%disp('ahcHexMessage(with padding) to be hashed is ::');
	   %%disp(MSG_2_PROC);
		N=MSG_L/(512*MFACT);
		tprint=sprintf('No. of %d-bit ahcHexMessage chunks=%d', MSG_SZ_P_BLK, N);
		%disp(tprint); 
	else 
		disp('Error in ahcHexMessage PreProcessing');
		disp('Check');
		return
	end

	%% Process MSG BLKs
	for blk_num=1:N

		padded_msg=MSG_2_PROC((512*MFACT*(blk_num-1)+1):blk_num*512*MFACT);

		%% Parse ahcHexMessage WORDs
		for i=1:16,
			for q=1:64
				W(i,q)=str2num(padded_msg(64*(i-1)+q));
			end
		end

		for i=17:80

		   %   Cal Sigma1(W(t-12))

			tmp1=W(i-2,:);
			tmp_ror= cat(2,tmp1(end-18:end),tmp1); 
			ror_19 = tmp_ror(1:64);

			tmp_ror= cat(2,tmp1(end-60:end),tmp1);
			ror_61 = tmp_ror(1:64);

			tmp_sh= cat(2,tmp1(end-5:end),tmp1);
			shr_6  = tmp_sh(1:64);
			shr_6(1,[1:6])=0;

			tmpx1  = bitxor(ror_19, ror_61);
			sigma1 = bitxor(shr_6,tmpx1); 

		   %   Cal Sigma0(W(t-15))

			tmp1=W(i-15,:);

			tmp_ror = cat(2,tmp1(end-0:end),tmp1);
			ror_1   = tmp_ror(1:64);

			tmp_ror = cat(2,tmp1(end-7:end),tmp1);
			ror_8   = tmp_ror(1:64);

			tmp_sh  = cat(2,tmp1(end-6:end),tmp1);
			shr_7   = tmp_sh(1:64);
			shr_7(1,[1:7])=0;

			tmpx1   = bitxor(ror_1, ror_8);
			sigma0  = bitxor(shr_7, tmpx1); 

			%%tmp_add = mod((bin2dec2(num2str(sigma1')') + bin2dec2(num2str(sigma0')') + bin2dec2(num2str((W(i-7,:))')') + bin2dec2(num2str((W(i-16,:))')')),(2^64));  
			tmp_add   = sigma1 + sigma0 + W(i-7,:) + W(i-16,:);  

			W(i,:)  = str2num(tConnection.AddMod64(tmp_add)')';
		end

		for j=1:64
			a(j)=str2num(h0(j));
			b(j)=str2num(h1(j));
			c(j)=str2num(h2(j));
			d(j)=str2num(h3(j));
			e(j)=str2num(h4(j));

			f(j)=str2num(h5(j));
			g(j)=str2num(h6(j));
			h(j)=str2num(h7(j));
			bitmask(j)=str2num(INV_M64(j));
		end

		for i=1:80

			ror_14  = cat(2, e(end-13:end),e);ror_14=ror_14(1:64);
			ror_18  = cat(2, e(end-17:end),e);ror_18=ror_18(1:64);
			ror_41  = cat(2, e(end-40:end),e);ror_41=ror_41(1:64);

			tmp_ror = bitxor(ror_14, ror_18); 
			S_SIG1  = bitxor(tmp_ror, ror_41);

			not_e   = bitxor(e,bitmask);
			and_ef  = bitand(e,f);
			and_fg  = bitand(not_e,g);
			ch_efg  = bitxor(and_ef, and_fg);

			add_sum1 = h + S_SIG1 + ch_efg + str2num(tConnection.Convt2Bin64(KT64(i,:))')' + W(i,:) ; 

			ror_28  = cat(2, a(end-27:end),a); ror_28  = ror_28(1:64);
			ror_34 = cat(2, a(end-33:end),a);  ror_34 = ror_34(1:64);
			ror_39 = cat(2, a(end-38:end),a);  ror_39 = ror_39(1:64);

			tmp_ror = bitxor(ror_28, ror_34); 
			S_SIG0  = bitxor(tmp_ror, ror_39);

			and_ab  = bitand(a,b); 
			and_bc  = bitand(b,c);
			and_ac  = bitand(a,c);

			xor_ab_bc = bitxor(and_ab,and_bc);

			maj_abc = bitxor(xor_ab_bc,and_ac);

			add_sum2  = maj_abc +  S_SIG0 ;  

			h=g;
			g=f;
			f=e;
			int_e= tConnection.AddMod64(add_sum1+d);
			for z=1:64
				e(z)=str2num(int_e(z));
			end
			d=c;
			c=b;
			b=a;
			int_a= tConnection.AddMod64 (add_sum1 + add_sum2);

			for z=1:64
				a(z)=str2num(int_a(z));
			end
		end

		h0_bin = tConnection.AddMod64(str2num(h0')' + a);
		h1_bin = tConnection.AddMod64(str2num(h1')' + b);
		h2_bin = tConnection.AddMod64(str2num(h2')' + c);
		h3_bin = tConnection.AddMod64(str2num(h3')' + d);
		h4_bin = tConnection.AddMod64(str2num(h4')' + e);
		h5_bin = tConnection.AddMod64(str2num(h5')' + f);
		h6_bin = tConnection.AddMod64(str2num(h6')' + g);
		h7_bin = tConnection.AddMod64(str2num(h7')' + h);

		h0 = h0_bin;
		h1 = h1_bin;
		h2 = h2_bin;
		h3 = h3_bin;
		h4 = h4_bin;
		h5 = h5_bin;
		h6 = h6_bin;
		h7 = h7_bin;

		H0=char();
		H1=char();
		H2=char();
		H3=char();
		H4=char();
		H5=char();
		H6=char();
		H7=char();

		for i=1:16
			H0 = strcat(dec2hex(bin2dec(h0_bin(end-((4*i)-1):end-(4*(i-1))))),H0);
			H1 = strcat(dec2hex(bin2dec(h1_bin(end-((4*i)-1):end-(4*(i-1))))),H1);
			H2 = strcat(dec2hex(bin2dec(h2_bin(end-((4*i)-1):end-(4*(i-1))))),H2);
			H3 = strcat(dec2hex(bin2dec(h3_bin(end-((4*i)-1):end-(4*(i-1))))),H3);
			H4 = strcat(dec2hex(bin2dec(h4_bin(end-((4*i)-1):end-(4*(i-1))))),H4);
			H5 = strcat(dec2hex(bin2dec(h5_bin(end-((4*i)-1):end-(4*(i-1))))),H5);
			H6 = strcat(dec2hex(bin2dec(h6_bin(end-((4*i)-1):end-(4*(i-1))))),H6);
			H7 = strcat(dec2hex(bin2dec(h7_bin(end-((4*i)-1):end-(4*(i-1))))),H7);
		end

		tConnection.achDigest = strcat(H0,H1,H2,H3,H4, H5,H6, H7);

	end

end % function


% This method works as follows:
%
% 
%
function RewriteSumboduleInLispFile(			...
			strFilepath,						...
			cstrSubmoduleName,					...
			cstrModuleName,						...
			afValues,							...
			bAreValuesIntegersAndNotFloats		)
	%
	% read the original file
	acFile = regexp( fileread(strFilepath), '\n', 'split');
	%
	% how many values shall we write per row in the lisp file
	iNumberOfElementsPerRow = 10;
	%
	% get the actual complete string in the lisp file
	cstrSubmoduleName = strcat( {'      '}, cstrSubmoduleName );
	%
	% get where in the module we are referring to this string
	[ iSignalStartIndex, iSignalEndIndex ] =	...
		IDAICEInterfacer.FindStartAndEndIndexesOfSubmodule( acFile, cstrSubmoduleName, cstrModuleName );
	%
	% check whether the signal has been found or not
	if( iSignalStartIndex == -1  ||  iSignalEndIndex == -1 )
		%
		disp(cstrSubmoduleName{1});
		error('the signal above has not been found in the original Lisp file!');
		%
	end;%
	%
	% in case that the signal is composed by more than one row, eliminate the unnecessary rows
	if( iSignalEndIndex > iSignalStartIndex )
		%
		acFile = acFile([1:iSignalStartIndex, (iSignalEndIndex+1):numel(acFile)]);
		%
	end;%
	%
	% counter
	iNumberOfElementsWrittenInTheCurrentRow = 0;
	%
	% initialization of the row index
	iCurrentRowIndex = iSignalStartIndex;
	%
	% cycle on the samples
	for iSample = 1:numel( afValues );
		%
		if( bAreValuesIntegersAndNotFloats )
			%
			cstrSubmoduleName = strcat(cstrSubmoduleName, sprintf(' %d', afValues(iSample)));
			%
		else%
			%
			cstrSubmoduleName = strcat(cstrSubmoduleName, sprintf(' %.2f', afValues(iSample)));
			%
		end;%
		%
		bBufferIsNotEmpty = true;
		%
		if( ~mod(iSample, iNumberOfElementsPerRow) )
			%
			% shift the rows down if it is at least the second writing performed
			if( iNumberOfElementsWrittenInTheCurrentRow > 0 )
				%
				for iRow = numel(acFile):-1:(iCurrentRowIndex);
					%
					acFile{iRow+1} = acFile{iRow};
					%
				end;%
				%
			end;%
			%
			% write the current one (notice that we make the conversion of the SignalName from cell to string)
			acFile{iCurrentRowIndex} = cstrSubmoduleName{1};
			%
			% reinitialize the times string
			cstrSubmoduleName = {'      '};
			%
			% increment the row and number of writings counters
			iCurrentRowIndex = iCurrentRowIndex + 1;
			iNumberOfElementsWrittenInTheCurrentRow = iNumberOfElementsWrittenInTheCurrentRow + 1;
			%
			% signal that there is stuff to be written
			bBufferIsNotEmpty = false;
			%
		end;%
		%
	end;%
	%
	% in case one has not emptied the current string then do it 
	if( bBufferIsNotEmpty )
		%
		% shift the rows down if it is at least the second writing performed
		if( iNumberOfElementsWrittenInTheCurrentRow > 0 )
			%
			for iRow = numel(acFile):-1:(iCurrentRowIndex);
				%
				acFile{iRow+1} = acFile{iRow};
				%
			end;%
			%
		end;%
		%
		acFile{iCurrentRowIndex} = cstrSubmoduleName{1};
		%
	end;%
	%
	% rewrite the file
	hFile = fopen(strFilepath, 'w');
	fprintf(hFile, '%s\n', acFile{:});
	fclose(hFile);
	%
end % function


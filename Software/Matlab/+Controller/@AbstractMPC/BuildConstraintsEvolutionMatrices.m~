% Prepare  cost matrices over the prediction orizon for deterministic MPC.
%
% function BuildConstraintsEvolutionMatrices( tController, afActuationBounds, afComfortBounds, iPredictionHorizon )
%
% TODO: describe how to give the inputs correctly
%
function BuildConstraintsEvolutionMatrices( tController, afActuationBounds, afComfortBounds, iPredictionHorizon )
	%
	try %
		% get the number of inputs and outputs
		%
		iNumberOfInputs		= size( tController.tModel.aafB, 2 );
		iNumberOfOutputs	= size( tController.tModel.aafC, 1 );
		%
		%------------------------------------------------------------------
		% build the constraint vector for one step
		%
		tController.tModel.aafGu	= [ -	eye( iNumberOfInputs )	;	...
											eye( iNumberOfInputs )	];
		tController.tModel.aafGy	= [ -	eye( iNumberOfOutputs ) ;	...
											eye( iNumberOfOutputs ) ];
		tController.tModel.afBu		= [ -	afActuationBounds	(1						:     iNumberOfInputs	)	,	...
											afActuationBounds	(iNumberOfInputs  + 1	: 2 * iNumberOfInputs	)	];
		tController.tModel.afBy		= [ -	afComfortBounds		(1						:     iNumberOfOutputs	)	;	...
											afComfortBounds		(iNumberOfOutputs + 1	: 2 * iNumberOfOutputs	)	];
		%
		%------------------------------------------------------------------
		% build the constraint matrices over the whole horizon
		%
		tController.tModel.aafGGu	= kron( eye( iPredictionHorizon ), tController.tModel.aafGu	);
		tController.tModel.aafGGy	= kron( eye( iPredictionHorizon ), tController.tModel.aafGy	);
		%
		tController.tModel.afBBu	= repmat( tController.tModel.afBu , iPredictionHorizon , 1);
		tController.tModel.afBBy	= repmat( tController.tModel.afBy , iPredictionHorizon , 1);
		%
		%
	catch exception
		%
		disp(exception.message)
		warning('Problems building the cost evolution matrices')
		%
	end;% end catch
	%
end % end function

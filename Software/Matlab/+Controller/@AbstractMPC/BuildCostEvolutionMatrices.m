% Prepare  cost matrices over the prediction orizon for deterministic MPC.
%
% function [	afExtendedLinearCostMatrixInput,				...
%				aafExtendedQuadraticCostMatrixInput   ] =	...
%					BuildCostEvolutionMatrices(			...
%						afLinearCostMatrix,				...
%						aafQuadraticCostMatrix,			...
%						tController.iPredictionHorizon					)
%
function BuildCostEvolutionMatrices( tController )
	%
	try %
		%
		iNumberOfOutput = size(tController.tModel.aafC, 2); % number of outputs
		iNumberOfInput = size(tController.tModel.aafC, 2); % number of outputs
		% Linear Contribution costruction 
		%
		afExtendedLinearCostMatrixInput = repmat(tController.afLinearCostFunctionMatrix , 1, tController.iPredictionHorizon);
		%
		afExtendedLinearCostMatrixSoftConstraints = tController.afRhoSoftConstraintsWeight * ones(iNumberOfOutput * tController.iPredictionHorizon, 1)';
		%
		tController.afExtendedLinearCostMatrix = [		afExtendedLinearCostMatrixInput,				...
														afExtendedLinearCostMatrixSoftConstraints];		...
		%
		% Quadratic Contribution costruction
		if ( isempty(tController.aafQuadraticCostFunctionMatrix) )
			%
			tController.aafExtendedQuadraticCostMatrix =[];
			%
		else%
			aafExtendedQuadraticCostMatrixInput = kron(eye(tController.iPredictionHorizon), tController.aafQuadraticCostFunctionMatrix );
			%
		%
			tController.aafExtendedQuadraticCostMatrix = [	aafExtendedQuadraticCostMatrixInput,									...	
															zeros(iNumberOfInput  * tController.iPredictionHorizon, tController.iPredictionHorizon * iNumberOfOutput);	...
															zeros(iNumberOfInput  * tController.iPredictionHorizon, iNumberOfOutput * tController.iPredictionHorizon),	...
															zeros(iNumberOfOutput * tController.iPredictionHorizon)];	
		end
		%
	catch exception
		%
		disp(exception.message)
		warning('Problems buildings the cost evolution matrices')
		%
	end;% end catch
	%
end % end function

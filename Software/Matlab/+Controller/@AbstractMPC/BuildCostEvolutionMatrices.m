% Prepare  cost matrices over the prediction orizon for deterministic MPC.
%
% function [	afExtendedLinearCostMatrixInput,				...
%				aafExtendedQuadraticCostMatrixInput   ] =	...
%					BuildCostEvolutionMatrices(			...
%						afLinearCostMatrix,				...
%						aafQuadraticCostMatrix,			...
%						tController.iPredictionHorizon					)
%
function BuildCostEvolutionMatrices( tController )
	%
	try %
		%
		iNumberOfOutput = size(tController.tModel.aafC, 2); % number of outputs
		iNumberOfInput	= size(tController.tModel.aafB, 2); % number of inputs
		% Linear Contribution costruction 
		%
		%
		% Allocating space for afExtendedLinearCostMatrixInput
		afExtendedLinearCostMatrixInput =									...
				zeros(	tController.iPredictionHorizon,						...
						tController.iPredictionHorizon*iNumberOfInput);		
		%
		%
		% Non variant case
		if ( numel( size( tController.afLinearCostFunctionMatrix) == 2))
			%
			afExtendedLinearCostMatrixInput = repmat(tController.afLinearCostFunctionMatrix , 1, tController.iPredictionHorizon);
			%
			% Variant case
		else
			%
			for iTimeStep = 1: tController.iPredictionHorizon
				%
				afExtendedLinearCostMatrixInput (	iTimeStep,												...
													(iTimeStep - 1) *	iNumberOfInput+1 :					...
													iTimeStep		*	iNumberOfInput						...
												)															...
												=															...
													tController.afLinearCostFunctionMatrix(:,:,iTimeStep);
				%
			end;% end for, building afExtendedLinearCostMatrixInput for the variant case
		end;% end if, deciding non variant or variant Linear cost matrix case
		%
		% Soft constraints
		%
		afExtendedLinearCostMatrixSoftConstraints =		tController.afRhoSoftConstraintsWeight			...		
													*	ones(1,		iNumberOfOutput						...
																*	tController.iPredictionHorizon);
		%
		%------------------------------------------------------------------
		% Merging the two matricies
		%
		tController.afExtendedLinearCostMatrix = [		afExtendedLinearCostMatrixInput,				...
														afExtendedLinearCostMatrixSoftConstraints];		...
		%
		%------------------------------------------------------------------
		%------------------------------------------------------------------
		% Quadratic Contribution costruction
		if ( isempty(tController.aafQuadraticCostFunctionMatrix) )
			%
			tController.aafExtendedQuadraticCostMatrix =[];
			%
		else
			%
			aafExtendedQuadraticCostMatrixInput = kron(eye(tController.iPredictionHorizon), tController.aafQuadraticCostFunctionMatrix );
			%
			tController.aafExtendedQuadraticCostMatrix = [	aafExtendedQuadraticCostMatrixInput,																		...	
															zeros(iNumberOfInput  * tController.iPredictionHorizon, tController.iPredictionHorizon * iNumberOfOutput);	...
															zeros(iNumberOfInput  * tController.iPredictionHorizon, iNumberOfOutput * tController.iPredictionHorizon),	...
															zeros(iNumberOfOutput * tController.iPredictionHorizon)];	
		end% end if presence Quadratic Cost
		%
	catch exception
		%
		disp(exception.message)
		warning('Problems buildings the cost evolution matrices')
		%
	end;% end catch
	%
end % end function

% Prepare  cost matrices over the prediction orizon for deterministic MPC.
%
% function BuildConstraintsEvolutionMatrices( tController )
%
% the afActuationBounds and afComfortBounds must be passed like colums
% for instance like

%TO DO: cambiare gli ingressi e riportare solo tController
%
function BuildConstraintsEvolutionMatrices( tController )
	%
	try %
		% get the number of inputs and outputs
		%
		iNumberOfInputs		= size( tController.tModel.aafB, 2 );
		iNumberOfOutputs	= size( tController.tModel.aafC, 1 );
		%
		if ( ~tController.bMixedConstraints )
			%------------------------------------------------------------------
			% build the constraint vector for one step
			%
			tController.tModel.aafGu	= [ -	eye( iNumberOfInputs )	;	...
												eye( iNumberOfInputs )		...
										  ];
			tController.tModel.aafGy	= [ -	eye( iNumberOfOutputs ) ;	...
												eye( iNumberOfOutputs )		...
										  ];
			tController.tModel.afBu		= vertcat( -	tController.tInputsBounds.afInputsLowerBounds,		...
														tController.tInputsBounds.afInputsUpperBounds		...
												  );
			tController.tModel.afBy		= vertcat( -	tController.tOutputsBounds.afOutputsLowerBounds,	...
														tController.tOutputsBounds.afOutputsUpperBounds		...
												 );
			%
			%------------------------------------------------------------------
			% build the constraint matrices over the whole horizon
			%
			tController.tModel.aafGGu	= kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGu	);
			tController.tModel.aafGGy	= kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGy	);
			%
			tController.tModel.afBBu	= repmat( tController.tModel.afBu , tController.iPredictionHorizon , 1);
			tController.tModel.afBBy	= repmat( tController.tModel.afBy , tController.iPredictionHorizon , 1);
			%
			%
		else
			% get size of Gx
			iRowSizeGx		= size(tController.tModel.aafGxMixed,1);		% Row size of GxMixed  it can be whatever the user decides)
			iColumnSizeGx	= size(tController.tModel.aafGxMixed,2);		% Column size of GxMixed ( it must be nx)
			%
			%
			% build the constrint vectors for one step
			tController.tModel.aafGy	= [ -	eye( iNumberOfOutputs ) ;									...
												eye( iNumberOfOutputs ) ];
			%
			tController.tModel.afBy		= vertcat( -	tController.tOutputsBounds.afOutputsLowerBounds,	...
														tController.tOutputsBounds.afOutputsUpperBounds		...
												 );
			%
			tController.tModel.aafGe  = [										...
											-eye(iNumberOfOutputs);				...
											 eye(iNumberOfOutputs)				...
										];
			%--------------------------------------------------------------
			%--------------------------------------------------------------
			% build the constraint matrices over the whole horizon
			%
			%
			%--------------------------------------------------------------
			tController.tModel.aafGGy	= kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGy	);
			%
			tController.tModel.afBBy	= repmat( tController.tModel.afBy , tController.iPredictionHorizon , 1);
			%
			% build RR over the whole prediction horizon
			tController.tModel.afRR =	repmat								...
										(	tController.tModel.afR,			...
											tController.iPredictionHorizon,		1);	
			%
			% build GGuMixed over the whole prediction horizon
			tController.tModel.aafGGuMixed = kron(eye( tController.iPredictionHorizon ), tController.tModel.aafGuMixed	);
			%
			%
			% extending Ge over the whole prediction horizon
			tController.tModel.aafGGe = kron(eye(tController.iPredictionHorizon), tController.tModel.aafGe);
			%
			% build RRx0 over the whole prediction horizon
			tController.tModel.aafRRx0 =	[	tController.tModel.aafGxMixed ; 
											%
											zeros(											...
														iRowSizeGx							...
													*  (tController.iPredictionHorizon-1),	...
														iColumnSizeGx						...
												 )											...
											];
			
			%
			% space allocation fo GGx
			%
			tController.tModel.aafGGxMixed = zeros(									...		
													tController.iPredictionHorizon 	...
												*	iRowSizeGx,						...
													tController.iPredictionHorizon	...
												*	iColumnSizeGx					...
											 );					
			%
			% building GGX, which is the extension of Gx over the whole prediction horizon 
			%
			for iPredictionHorizonStepTime = 1:1:(tController.iPredictionHorizon -1)
			%
			tController.tModel.aafGGxMixed(										...
										(		iPredictionHorizonStepTime		...
											*	iRowSizeGx						...
										) + 1									...
										:										...
										(iPredictionHorizonStepTime + 1)		...
										*	iRowSizeGx,							...
										(iPredictionHorizonStepTime - 1)		...
										*	iColumnSizeGx + 1					...
										:										...
											iPredictionHorizonStepTime			...
										*	iColumnSizeGx						...
									 )											...
									 =	tController.tModel.aafGxMixed;			...
			%						 
			end% end for
			% 
			
		end % end of if
		%------------------------------------------------------------------
	catch exception
		%
		disp(exception.message)
		warning('Problems building the cost evolution matrices')
		%
	end;% end catch
	%
end % end function

% Prepare  cost matrices over the prediction orizon for deterministic MPC.
%
% function BuildConstraintsEvolutionMatrices( tController )
%
% the afActuationBounds and afComfortBounds must be passed like colums
% for instance like
%
function BuildConstraintsEvolutionMatrices( tController )
	%
	try %
		% get the number of inputs and outputs
		%
		iNumberOfInputs			= size( tController.tModel.aafB, 2 );
		iNumberOfOutputs		= size( tController.tModel.aafC, 1 );
		
		%
		if ( ~tController.bMixedConstraints )
			%------------------------------------------------------------------
			% build the constraint vectors for one step
			%
			tController.tModel.aafGu	= [ -	eye( iNumberOfInputs )	;	...
												eye( iNumberOfInputs )		...
										  ];
			tController.tModel.aafGy	= [ -	eye( iNumberOfOutputs ) ;	...
												eye( iNumberOfOutputs )		...
										  ];
			tController.tModel.afBu		= vertcat( -	tController.tInputsBounds.afInputsLowerBounds,		...
														tController.tInputsBounds.afInputsUpperBounds		...
												  );
			%
			%------------------------------------------------------------------
			% build the constraint matrices over the whole horizon
			%
			tController.tModel.aafGGu	= kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGu	);
			tController.tModel.aafGGy	= kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGy	);
			%
			tController.tModel.afBBu	= repmat( tController.tModel.afBu , tController.iPredictionHorizon , 1);
			tController.tModel.afBBy	= tController.tModel.aafBy(:);
			%
			%
		else
			% get size of Gx
			iRowSizeGx		= size(tController.tModel.aafGxMixed,1);		% Row size of GxMixed  it can be whatever the user decides)
			iColumnSizeGx	= size(tController.tModel.aafGxMixed,2);		% Column size of GxMixed ( it must be nx)
			%
			%-------------------------------------------------------------
			% build the constraint vectors for one step
			tController.tModel.aafGy	= [ -	eye( iNumberOfOutputs ) ;									...
												eye( iNumberOfOutputs ) ];
			%
			tController.tModel.aafGe  = [										...
											 eye(iNumberOfOutputs);				...
											 eye(iNumberOfOutputs)				...
										];
			%--------------------------------------------------------------
			%--------------------------------------------------------------
			% build the constraint matrices over the whole horizon
			%
			%
			%--------------------------------------------------------------
			tController.tModel.aafGGy	= kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGy	);
			%
			tController.tModel.afBBy	= tController.tModel.aafBy(:);
			%
			% build RR over the whole prediction horizon
			tController.tModel.afRR =	repmat								...
										(	tController.tModel.afR,			...
											tController.iPredictionHorizon,		1);	
			%
			% build GGuMixed over the whole prediction horizon
			tController.tModel.aafGGuMixed = kron(eye( tController.iPredictionHorizon ), tController.tModel.aafGuMixed	);
			%
			%
			% extending Ge over the whole prediction horizon
			tController.tModel.aafGGe = kron(eye(tController.iPredictionHorizon), tController.tModel.aafGe);
			%
			% build RRx0 over the whole prediction horizon
			tController.tModel.aafRRx0 =	[	tController.tModel.aafGxMixed ; 
											%
											zeros(											...
														iRowSizeGx							...
													*  (tController.iPredictionHorizon-1),	...
														iColumnSizeGx						...
												 )											...
											];
			
			%
			% space allocation fo GGx
			%
			tController.tModel.aafGGxMixed = zeros(									...		
													tController.iPredictionHorizon 	...
												*	iRowSizeGx,						...
													tController.iPredictionHorizon	...
												*	iColumnSizeGx					...
											 );					
			%
			% building GGX, which is the extension of Gx over the whole prediction horizon 
			%
			for iPredictionHorizonStepTime = 1:1:(tController.iPredictionHorizon -1)
			%
			tController.tModel.aafGGxMixed(										...
										(		iPredictionHorizonStepTime		...
											*	iRowSizeGx						...
										) + 1									...
										:										...
										(iPredictionHorizonStepTime + 1)		...
										*	iRowSizeGx,							...
										(iPredictionHorizonStepTime - 1)		...
										*	iColumnSizeGx + 1					...
										:										...
											iPredictionHorizonStepTime			...
										*	iColumnSizeGx						...
									 )											...
									 =	tController.tModel.aafGxMixed;			...
			%						 
			end% end for
			% 
			
		end % end of if
			%
			%--------------------------------------------------------------
			% Other linear constraints on inputs
			%
		if	( ~tController.bLinearInputsConstraints )
			%	
			tController.tModel.aafGGu = zeros(											...
													tController.iPredictionHorizon * 2	...
												*	iNumberOfInputs,					...
													tController.iPredictionHorizon		...
												*	iNumberOfInputs						...
											 );
			%								 
			tController.tModel.afBBu  = zeros(											...
													tController.iPredictionHorizon * 2	...
												*	iNumberOfInputs,					...
													1									...
											 );	
			%
		else
			%--------------------------------------------------------------
			% build the constraint vectors for one step
			%	
			tController.tModel.afBu		= vertcat(		-tController.tInputsBounds.afInputsLowerBounds,		...
														 tController.tInputsBounds.afInputsUpperBounds		...
												  );	
			%--------------------------------------------------------------
			% build the constraint vectors over the whole prdiction horizon
			%
			tController.tModel.aafGGu = zeros(											...
													tController.iPredictionHorizon * 2	...
												*	iNumberOfInputs,					...
													tController.iPredictionHorizon		...
												*	iNumberOfInputs						...
											 );
			%
			if (isfield(tController.tModel, 'aaafGu') == 1) % variant case
				%
				
				iRowSizeGu = size(tController.tModel.aaafGu, 1);
				%
				tController.tModel.aafGGu = zeros(										...
													tController.iPredictionHorizon		...
												*	iRowSizeGu,							...
													tController.iPredictionHorizon		...
												*	iNumberOfInputs						...
											 );
				%
				for iStepTime = 1:1:tController.iPredictionHorizon
					%
					tController.tModel.aafGGu													...
						(																		...
								( ( iStepTime - 1 ) * iRowSizeGu )	+ 1							...
							:		iStepTime		* iRowSizeGu,								...
								( ( iStepTime - 1 ) * iNumberOfInputs )	+ 1						...
							:		iStepTime * iNumberOfInputs									...			
						)						...
								=	tController.tModel.aaafGu(:,:, iStepTime);	 			
				end % end of for
				%
			else
				%
				tController.tModel.aafGu	= [ -	eye( iNumberOfInputs )	;	...
													eye( iNumberOfInputs )		...
										  ];
				%
				tController.tModel.aafGGu = kron(eye(tController.iPredictionHorizon), tController.tModel.aafGu);
				%
			end;% end if variant case
			%
			tController.tModel.afBu		= vertcat( -	tController.tInputsBounds.afInputsLowerBounds,		...
														tController.tInputsBounds.afInputsUpperBounds		...
												  );
			%
			tController.tModel.afBBu = repmat( tController.tModel.afBu , tController.iPredictionHorizon , 1);
			%
		end;% end if LinearConstraints
			
		%------------------------------------------------------------------
		%------------------------------------------------------------------
		% Soft constraints on Mixed Constraints
		%
		if	( ~tController.bSoftConstraintsOnMixedConstraints )
			%	
			tController.tModel.aafGGeMixed =	zeros(													...
															tController.iPredictionHorizon				...
														*	size( tController.tModel.aafGxMixed , 1),	...
															iNumberOfOutputs							...
														*	tController.iPredictionHorizon				...
													 );	
			
			%
		else
			%--------------------------------------------------------------
			% build the soft constraints matrices over prediction horizon
			%	
			tController.tModel.aafGGeMixed = kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGeMixed	);
			%
		end % end if LinearConstraints
			
		%--------------------------------------
	catch exception
		%
		disp(exception.message)
		warning('Problems building the constraints evolution matrices')
		%
	end;% end catch
	%
end % end function

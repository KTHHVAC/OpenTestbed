% Prepare  cost matrices over the prediction orizon for deterministic MPC.
%
% function BuildConstraintsEvolutionMatrices( tController )
%
% the afActuationBounds and afComfortBounds must be passed like colums
% for instance like
%
function BuildConstraintsEvolutionMatrices( tController )
	%
	try %
		% get the number of inputs and outputs
		%
		iNumberOfInputs			= size( tController.tModel.aafB, 2 );
		iNumberOfOutputs		= size( tController.tModel.aafC, 1 );
		
		%
		if ( ~tController.bMixedConstraints )
			%------------------------------------------------------------------
			% build the constraint vectors for one step
			%
			tController.tModel.aafGu	= [ -	eye( iNumberOfInputs )	;	...
												eye( iNumberOfInputs )		...
										  ];
			tController.tModel.aafGy	= [ -	eye( iNumberOfOutputs ) ;	...
												eye( iNumberOfOutputs )		...
										  ];
			tController.tModel.afBu		= vertcat( -	tController.tInputsBounds.afInputsLowerBounds,		...
														tController.tInputsBounds.afInputsUpperBounds		...
												  );
			%
			%------------------------------------------------------------------
			% build the constraint matrices over the whole horizon
			%
			tController.tModel.aafGGu	= kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGu	);
			tController.tModel.aafGGy	= kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGy	);
			%
			tController.tModel.afBBu	= repmat( tController.tModel.afBu , tController.iPredictionHorizon , 1);
			tController.tModel.afBBy	= tController.tModel.aafBy(:);
			%
			%
		else
			% get size of Gx
 			iRowSizeGx		= size(tController.tModel.aaafGxMixed,1);		% Row size of GxMixed  it can be whatever the user decides)
 			iColumnSizeGx	= size(tController.tModel.aaafGxMixed,2);		% Column size of GxMixed ( it must be nx)
			%
			%-------------------------------------------------------------
			% build the constraint vectors for one step
			tController.tModel.aafGy	= [ -	eye( iNumberOfOutputs ) ;									...
												eye( iNumberOfOutputs ) ];
			%
			tController.tModel.aafGe  = [										...
											 eye(iNumberOfOutputs);				...
											 eye(iNumberOfOutputs)				...
										];
			%--------------------------------------------------------------
			%--------------------------------------------------------------
			% build the constraint matrices over the whole horizon
			%
			%
			%--------------------------------------------------------------
			tController.tModel.aafGGy	= kron( eye( tController.iPredictionHorizon ), tController.tModel.aafGy	);
			%
			tController.tModel.afBBy	= tController.tModel.aafBy(:);
			%
			% build RR over the whole prediction horizon
			%
			tController.tModel.afRR = tController.tModel.aafR(:);
			%
			% build GGuMixed over the whole prediction horizon
			tController.tModel.aafGGuMixed = kron(eye( tController.iPredictionHorizon ), tController.tModel.aafGuMixed	);
			%
			%
			% extending Ge over the whole prediction horizon
			tController.tModel.aafGGe = kron(eye(tController.iPredictionHorizon), tController.tModel.aafGe);
			%
			% build RRx0 over the whole prediction horizon
			tController.tModel.aafRRx0 =	[	tController.tModel.aaafGxMixed(:,:,1) ; 
											%
											zeros(											...
														iRowSizeGx							...
													*  (tController.iPredictionHorizon-1),	...
														iColumnSizeGx						...
												 )											...
											];
			
			%
			% space allocation fo GGx
			%
			tController.tModel.aafGGxMixed = zeros(									...		
													tController.iPredictionHorizon 	...
												*	iRowSizeGx,						...
													tController.iPredictionHorizon	...
												*	iColumnSizeGx					...
											 );					
			%
			% building GGX, which is the extension of Gx over the whole prediction horizon 
			%
			for iPredictionHorizonStepTime = 1:1:(tController.iPredictionHorizon -1)
			%
			tController.tModel.aafGGxMixed(																	...
										(		iPredictionHorizonStepTime									...
											*	iRowSizeGx													...
										) + 1																...
										:																	...
										(iPredictionHorizonStepTime + 1)									...
										*	iRowSizeGx,														...
										(iPredictionHorizonStepTime - 1)									...
										*	iColumnSizeGx + 1												...
										:																	...
											iPredictionHorizonStepTime										...
										*	iColumnSizeGx													...
									 )																		...
									 =	tController.tModel.aaafGxMixed(:, :, iPredictionHorizonStepTime+1);	...
			%						 
			end% end for
			% 
			
		end % end of if
			%
			%--------------------------------------------------------------
			% Other linear constraints on inputs
			%
		if	( ~tController.bLinearInputsConstraints )
			%	
			tController.tModel.aafGGu = zeros(											...
													tController.iPredictionHorizon * 2	...
												*	iNumberOfInputs,					...
													tController.iPredictionHorizon		...
												*	iNumberOfInputs						...
											 );
			%								 
			tController.tModel.afBBu  = zeros(											...
													tController.iPredictionHorizon * 2	...
												*	iNumberOfInputs,					...
													1									...
											 );	
			%
		else
			%--------------------------------------------------------------
			% build the constraint vectors for one step
			%	
			tController.tModel.afBu		= vertcat(		-tController.tInputsBounds.afInputsLowerBounds,		...
														 tController.tInputsBounds.afInputsUpperBounds		...
												  );	
			%--------------------------------------------------------------
			% build the constraint vectors over the whole prdiction horizon
			%
			tController.tModel.aafGGu = zeros(											...
													tController.iPredictionHorizon * 2	...
												*	iNumberOfInputs,					...
													tController.iPredictionHorizon		...
												*	iNumberOfInputs						...
											 );
			%
			if (isfield(tController.tModel, 'aaafGu') == 1) % variant case
				%
				
				iRowSizeGu = size(tController.tModel.aaafGu, 1);
				%
				tController.tModel.aafGGu = zeros(										...
													tController.iPredictionHorizon		...
												*	iRowSizeGu,							...
													tController.iPredictionHorizon		...
												*	iNumberOfInputs						...
											 );
				%
				for iStepTime = 1:1:tController.iPredictionHorizon
					%
					tController.tModel.aafGGu													...
						(																		...
								( ( iStepTime - 1 ) * iRowSizeGu )	+ 1							...
							:		iStepTime		* iRowSizeGu,								...
								( ( iStepTime - 1 ) * iNumberOfInputs )	+ 1						...
							:		iStepTime * iNumberOfInputs									...			
						)						...
								=	tController.tModel.aaafGu(:,:, iStepTime);	 			
				end % end of for
				%
			else
				%
				tController.tModel.aafGu	= [ -	eye( iNumberOfInputs )	;	...
													eye( iNumberOfInputs )		...
										  ];
				%
				tController.tModel.aafGGu = kron(eye(tController.iPredictionHorizon), tController.tModel.aafGu);
				%
			end;% end if variant case
			%
			tController.tModel.afBu		= vertcat( -	tController.tInputsBounds.afInputsLowerBounds,		...
														tController.tInputsBounds.afInputsUpperBounds		...
												  );
			%
			tController.tModel.afBBu = repmat( tController.tModel.afBu , tController.iPredictionHorizon , 1);
			%
		end;% end if LinearConstraints
			
		%------------------------------------------------------------------
		%------------------------------------------------------------------
		% Soft constraints on Mixed Constraints
		%
		tController.tModel.aafGGeMixed =	zeros(														...
															tController.iPredictionHorizon				...
														*	size( tController.tModel.aaafGxMixed , 1),	...
															iNumberOfOutputs							...
														*	tController.iPredictionHorizon				...
													 );	
		if	( ~tController.bSoftConstraintsOnMixedConstraints )
			%	
			% do nothing
			%
		else
			%--------------------------------------------------------------
			% build the soft constraints matrices over prediction horizon
			%	
			for iStepTime = 1 : tController.iPredictionHorizon
				%
				iNumberOfRows						= size(tController.tModel.aaafGeMixed,1);
				iNumberOfColumns					= size(tController.tModel.aaafGeMixed,2);
				%
				tController.tModel.aafGGeMixed(	1 + (iStepTime-1)*iNumberOfRows		:	iStepTime*iNumberOfRows,		...
												1 + (iStepTime-1)*iNumberOfColumns	:	iStepTime*iNumberOfColumns )	...
					= tController.tModel.aaafGeMixed(:,:,iStepTime);
				
				%
				%
			end; % end for LinearConstraints
		end; %end if
			
		%--------------------------------------
	catch exception
		%
		disp(exception.message)
		warning('Problems building the constraints evolution matrices')
		%
	end;% end catch
	%
end % end function

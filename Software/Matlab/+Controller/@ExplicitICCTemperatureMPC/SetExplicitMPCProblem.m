	function SetExplicitMPCProblem( tController )
	%Setting all the matrices of the linear time inveriant discrete model
	%
	try %
		%
		iNumberOfInputs		= size(tController.tModel.aafB,2);
		iNumberOfOutputs	= size(tController.tModel.afC,1);
		iHorizonLength		= tController.iPredictionHorizon;	
		iNumberOfScenarios	= tController.iNumberOfScenarios;
		fprobScen			= 1/iNumberOfScenarios;
		beta				= 1;
		%------------------------------------------------------------------
		% setup the problem
		%
		x0  = sdpvar(2,1);
		u	= sdpvar(repmat(iNumberOfInputs,	iHorizonLength, 1),		ones(iHorizonLength,1));
		eps = sdpvar(repmat(iHorizonLength,		iNumberOfScenarios, 1), ones(iNumberOfScenarios,1));
		z	= sdpvar(repmat(iNumberOfOutputs,	iNumberOfScenarios, 1), ones(iNumberOfScenarios,1));
		%
		aafA		=	tController.tModel.aafA;
		aafB		=	tController.tModel.aafB;
		afC			=	tController.tModel.afC;
		aafE		=	tController.tModel.aafE;
		%
		afBMix		=	tController.tModel.afBMixed;
		afBuMin		=	tController.tInputsBounds.afBuMin;
		afBuMax		=	tController.tInputsBounds.afBuMax;
		afByMin		=	tController.tOutputsBounds.fLowerBound;
		afByMax		=	tController.tOutputsBounds.fUpperBound;
		aafGu		=	tController.tModel.aafGu;
		aafGuMix	=	tController.tModel.aafGuMix;
		aafGxMix	=	tController.tModel.aafGxMix;
		aafGeMix	=	tController.tModel.aafGeMix;
		aafW		=	tController.tModel.aafScenarios;
		%
		afLinCost	=	tController.afLinearCostMatrix;
		%
		constraints = [];
		sum			= 0;		
		objective	= 0;
		x			= x0;
		%
		for i = 1:iNumberOfScenarios
			%
			for k = 1:iHorizonLength
				%
				aafWa = aafW(:,i,k);
				x =	aafA * x + aafB	* u{k} + aafE * aafWa ;
				%
				constraints =	[	constraints,																				...
									afByMin - eps{i}(k)										<= afC * x	<= afByMax + eps{i}(k),	...
									afBuMin													<= u{k}		<= afBuMax ,			...
									aafGu*u{k}												<= zeros(2,1),						...
									aafGuMix * u{k} + aafGxMix * x	+ aafGeMix * eps{i}(k)	<= afBMix,							...
									eps{i}(k)												>= 0								...
									eps{i}(k)												<= z{i}								...
									];
				%
			end %
			sum = sum + fprobScen*z{i};
		end %
		%
		constraints = [constraints, sum <= beta]; 
		for k = 1:iHorizonLength
			%
			objective = objective + afLinCost * u{k};
		end %
		%
		tController.tConstraints	=	constraints;
		tController.tObjective		=	objective;
		tController.tx0				=	x0;
		tController.u				=	u;
		%
		%
	catch exception
		%
		disp(exception.message);
		warning('Problems computing the control inputs.');
		%
	end;% end catch		
	%
end % end function

		
classdef ExperimentalPIController < Controller.Controller & Controller.ControllerInterface
	
	%===============================================================================
	% Authors:   Daniel Risberg, KTH, Royal Institute of Technology
	% (04-04-2013: first implementation)
	%===============================================================================
	
	properties(GetAccess = 'public', SetAccess = 'public') %SetAccess ='private' is original
		% some doc: http://www.mathworks.se/help/simulink/examples/anti-windup-control-using-a-pid-controller.html
		%			http://ctms.engin.umich.edu/CTMS/index.php?example=Introduction&section=ControlPID
		iteration;
		bHasToWork;
		
		objController;
		fProportionalGain;
		fIntegralGain;
		fDerivativeGain;
		afActuationsC;			% Array with the Cooling actuation values
		afActuationsV;			% Array with the Ventilation actuation values
		afActuationsH;			% Array with the Heating actuation values
		afMeasuredCO2Values;    % Array with measured CO2 values
		actTime;
		Runtime;
		fIntFilter;
		fIntTimeCte;
		fDerFilter;
		fDerTimeCte;
		X0;
		U0;
		W0;
		outputC;
		outputV;
		outputH;
		aiCurrentTemp;
		aiCurrentCO;
		comfort;
		setpoint;
		deadzone;
		CurrentWeather;
		CurrentOccupancy;
		fAntiWindUp;
		fInitialValue;
		error;
		intErrorH;
		intErrorC;
		hilimit;
		lolimit;
		hi;
		lo;
		center;
		radius;
		gain;
		propband;
		errorV;
		errorH;
		CO2Setpoint;
		CO2Comfort;
		CO2max;
		CO2min;
		CO2Error;
		CO2Gain;
		CO2Output;
		errorC;
		VentOutput;
		aiCurrentWeather;
		aiCurrentMotion;
		aiCurrentOccupancy;
		CurrentOutsideTemp;
		SetpointT;
		ComfortT
		DeadzoneT;
		RealDeadzoneT;
		FakeDeadzoneT;
		DeltaDeadzoneT;
		
		CO2Deadzone;
		CO2RealDeadzone;
		CO2FakeDeadzone;
		CO2DeltaDeadzone;
		
		PgainT;
		intTimeT;
		
		DeadzoneTPlot;
		CO2DeadzonePlot;
		SetpointTPlot;
		CO2SetpointPlot;
		
		ControlOutput;
		RateLimit;
		tTCPConnection;
		DeviceID;
		
		SensorSignalID;
		
		ActuatorSignalID;
		
		afMeasuredValues;
		
		fRadiatorInput;
		
		fTemperatureReference;
		
		fVentilationInput;
		
		fIntegrationOfTheTemperatureError;
		
	end
	
	methods(Access = 'public')
		
		function tController = ExperimentalPIController( tParameters, tTCPConnection )
			
			tParameters.bSaveWorkspaceEachIteration			= false;
			tParameters.bSaveResults						= true;
			
			tController = tController@Controller.Controller( tParameters );
			
			% addprop(pid,'tTCPConnection')
			
			tController.tTCPConnection			= tTCPConnection;
			tController.DeviceID				= [1043 2002]; %Mote(Temperature), PLC(CO2)
			tController.SensorSignalID			= [10 30];
			tController.ActuatorSignalID		= [61 62 63 65];
			tController.Runtime                 = 12; %In hours
			tController.actTime                 = 30; %In seconds
			tController.intErrorH               = 0;
			tController.intErrorC               = 0;
			tController.SetpointT               = 22; %Maybe 22 +- 1
			tController.ComfortT                = 1;
			tController.DeadzoneT               = 1;
			tController.RealDeadzoneT           = 1; %Deadzone normally half of Comfort zone
			tController.FakeDeadzoneT           = 0;
			tController.DeltaDeadzoneT          = 0;%This can change, or not :)
			tController.PgainT                  = 0.7; %Original 0.3 from IDA
			tController.intTimeT                = 200; %Original 300 from IDA
			tController.CO2Setpoint             = 450;%Fix
			tController.CO2Comfort              = 50;%Fix
			tController.CO2max                  = tController.CO2Setpoint + tController.CO2Comfort; %Value when output becomes saturated
			tController.CO2min                  = tController.CO2Setpoint - tController.CO2Comfort; %Value when output becomes saturated
			tController.CO2Gain                 = 1/(tController.CO2max- tController.CO2min);
			tController.CO2Deadzone             = 25;
			tController.CO2RealDeadzone         = 25; %Deadzone normally half of Comfort zone
			tController.CO2FakeDeadzone         = 0;
			tController.CO2DeltaDeadzone        = 0;%Maybe not needed?
			tController.hi                      = tController.SetpointT + tController.ComfortT; %Value when ventilation output is saturated
			tController.lo                      = tController.SetpointT - tController.ComfortT; %Value when ventilation output is CO2Output
			tController.propband                = (tController.hi - tController.lo);  %tController.lo kanska ska vara tController.SetpointT
			tController.ControlOutput           = [0 0 0 0];
			tController.RateLimit               = 25;
			tController.hilimit                 = 1;
			tController.lolimit                 = 0;
			tController.afMeasuredValues = [];
			
			tController.bHasToWork								= false;
			
		end
		
% 		function pid = AcquireForecasts( pid )
% 			pid.AddError( 'PIDController.AcquireForecasts: Forecast is only available for MPC controllers' );
% 		end
% 		
% 		function pid = AcquireMeasurements( pid )
% 			try
% 				
% 				%Gets measurments of current temperature and CO2
% 
% 				%Temperature part
% 				
% 				pid.tTCPConnection.GetDataFromMote( pid.DeviceID(1), 'T', pid.SensorSignalID(1) );
% 				pid.aiCurrentTemp = str2double( char(pid.tTCPConnection.tMessage.acData{1,13}));
% 				pid.afMeasuredValues(length(pid.afMeasuredValues) + 1) = pid.aiCurrentTemp;
% 				
% 				%CO2 part
% 				
% 				pid.tTCPConnection.GetDataFromPLC( pid.DeviceID(2), 'C', pid.SensorSignalID(2) );
% 				pid.aiCurrentCO = str2double(char(pid.tTCPConnection.tMessage.acData{13}));
% 				pid.afMeasuredCO2Values(length(pid.afMeasuredCO2Values) + 1) = pid.aiCurrentCO;
% 				
% 			catch exception
% 				
% 				pid.AddError( strcat('PIDController.AcquireMeasurements: ', exception.message) );
% 			end
% 		end
% 		
% 		
% 		
% 		function pid = AcquireCurrentOccupancy( pid )
% 			
% 			%Gets the current Occupancy
% 			
% 			pid.tTCPConnection.GetDataFromPeopleCounter( );
% 			pid.aiCurrentOccupancy.src = char(pid.tTCPConnection.tMessage.acData{1,9});
% 			pid.aiCurrentOccupancy.devID = char(pid.tTCPConnection.tMessage.acData{1,10});
% 			pid.aiCurrentOccupancy.data = char(pid.tTCPConnection.tMessage.acData{1,11});
% 			pid.aiCurrentOccupancy.signID = char(pid.tTCPConnection.tMessage.acData{1,12});
% 			pid.aiCurrentOccupancy.value = char(pid.tTCPConnection.tMessage.acData{1,13});
% 			pid.aiCurrentOccupancy.time = char(pid.tTCPConnection.tMessage.acData{1,14});
% 			pid.aiCurrentOccupancy.loc = char(pid.tTCPConnection.tMessage.acData{1,15});
% 			pid.aiCurrentOccupancy.xyz = char(pid.tTCPConnection.tMessage.acData{1,16});
% 
% 			
% 			%Device ID for the PLC is 2002, M stands for Motion, 51 is the
% 			%Motion Signal ID
% 			
% 			deviceID = 2002;
% 			signalID = 51;
% 			dataType = 'M';
% 			
% 			pid.tTCPConnection.GetDataFromPLC( deviceID, dataType, signalID );
% 			pid.aiCurrentMotion.src = char(pid.tTCPConnection.tMessage.acData{1,9});
% 			pid.aiCurrentMotion.devID = char(pid.tTCPConnection.tMessage.acData{1,10});
% 			pid.aiCurrentMotion.data = char(pid.tTCPConnection.tMessage.acData{1,11});
% 			pid.aiCurrentMotion.signID = char(pid.tTCPConnection.tMessage.acData{1,12});
% 			pid.aiCurrentMotion.value = char(pid.tTCPConnection.tMessage.acData{1,13});
% 			pid.aiCurrentMotion.time = char(pid.tTCPConnection.tMessage.acData{1,14});
% 			pid.aiCurrentMotion.loc = char(pid.tTCPConnection.tMessage.acData{1,15});
% 			pid.aiCurrentMotion.xyz = char(pid.tTCPConnection.tMessage.acData{1,16});
% 			
% 			if( str2double(pid.aiCurrentMotion.value) == 0 )
% 				
% 				pid.aiCurrentOccupancy.value = 0;
% 				
% 			end
% 		end
% 
% 		function pid = AcquireWeather( pid )
% 			
% 			%Gets the current Weather
% 			
% 			pid.tTCPConnection.GetCurrentWeatherSituation;
% 
% 			pid.aiCurrentWeather.weather = char(pid.tTCPConnection.tMessage.acData{1,18});
% 			pid.aiCurrentWeather.temp = char(pid.tTCPConnection.tMessage.acData{1,19});
% 			pid.aiCurrentWeather.relhum = char(pid.tTCPConnection.tMessage.acData{1,20});
% 			pid.aiCurrentWeather.wnd = char(pid.tTCPConnection.tMessage.acData{1,21});
% 			pid.aiCurrentWeather.wnddirA = char(pid.tTCPConnection.tMessage.acData{1,22});
% 			pid.aiCurrentWeather.wnddirB = char(pid.tTCPConnection.tMessage.acData{1,23});
% 			pid.aiCurrentWeather.wndspd = char(pid.tTCPConnection.tMessage.acData{1,24});
% 			pid.aiCurrentWeather.wndgst = char(pid.tTCPConnection.tMessage.acData{1,25});
% 			pid.aiCurrentWeather.press = char(pid.tTCPConnection.tMessage.acData{1,26});
% 			pid.aiCurrentWeather.dew = char(pid.tTCPConnection.tMessage.acData{1,27});
% 			pid.aiCurrentWeather.wndchl = char(pid.tTCPConnection.tMessage.acData{1,28});
% 			pid.aiCurrentWeather.feels = char(pid.tTCPConnection.tMessage.acData{1,29});
% 			pid.aiCurrentWeather.vis = char(pid.tTCPConnection.tMessage.acData{1,30});
% 			pid.aiCurrentWeather.rad = char(pid.tTCPConnection.tMessage.acData{1,31});
% 			pid.aiCurrentWeather.uv = char(pid.tTCPConnection.tMessage.acData{1,32});
% 			pid.aiCurrentWeather.precA = char(pid.tTCPConnection.tMessage.acData{1,33});
% 			pid.aiCurrentWeather.precB = char(pid.tTCPConnection.tMessage.acData{1,34});
% 			pid.aiCurrentWeather.radiation = 0;
% 			
% 		end
% 
% 		function pid = AcquireMeasurementsDaniel( pid )
% 			
% 			%Gets the data from the motes
% 			% MoteID = [1002 1006 1007 1213 1005 1003 1011 1109 1036 1034
% 			% 1037 1038 8888]; %8888 = TBD
% 			
% 			MoteID = [1002 1006 1007 1213 1005 1003 1011 1109 1036 1034 1037 1038 1037];
% 			TempSignID = [10 19 10 10 10 10 10 10 1036 1034 1037 1038 1038];
% 			PlcID = 2002;
% 			CoSignID = 30;
% 			MoteCID = [1001 1004]; %Mote CO2 ID
% 			CoMSignID = [32 31]; % Mote CO Sign ID
% 			
% 			for i = 1:length( MoteID )
% 				
% 				pid.tTCPConnection.GetDataFromMote( MoteID( i ), 'T', TempSignID( i ) );
% 				pid.aiCurrentTemp.tAll(i) = str2double(char(pid.tTCPConnection.tMessage.acData{13}));
% 				
% 			end
% 
% 			pid.tTCPConnection.GetDataFromPLC( PlcID, 'C', CoSignID );
% 			pid.aiCurrentCO = str2double(char(pid.tTCPConnection.tMessage.acData{13}));
% 			
% 			for i = 1:length(CoMSignID)
% 				
% 				pid.tTCPConnection.GetDataFromMote( MoteCID( i ) , 'C', CoMSignID( i ) );
% 				pid.aiCurrentCO(i + 1) = str2double(char(pid.tTCPConnection.tMessage.acData{13}));
% 				
% 			end
% 		end

% % % 		function pid = ComputeControlInputs( pid )
% % % 			
% % % 			try
% % % 				
% % % 				%Resets all previous control outputs
% % % 				
% % % 				pid.outputC = 0;
% % % 				pid.outputH = 0;
% % % 				pid.VentOutput = 0;
% % % 				pid.outputV = 0;
% % % 				
% % % 				if length(pid.afMeasuredValues) < pid.iteration
% % % 					
% % % 					pid.afMeasuredValues(end +1) = pid.aiCurrentTemp;
% % % 					
% % % 				end
% % % 				
% % % 				if length(pid.afMeasuredCO2Values) < pid.iteration
% % % 					
% % % 					pid.afMeasuredCO2Values(end +1) = pid.aiCurrentCO;
% % % 					
% % % 				end
% % % 				
% % % 				%Checks if deadzone or setpoint have been passed
% % % 				
% % % 				if pid.iteration ~= 1
% % % 					
% % % 					%Temperature deadzone and setpoint case
% % % 					
% % % 					if (pid.afMeasuredValues(pid.iteration - 1) >= pid.SetpointT + pid.RealDeadzoneT) && (pid.afMeasuredValues(pid.iteration) <= pid.SetpointT + pid.RealDeadzoneT) && (pid.DeadzoneT == pid.RealDeadzoneT)
% % % 						
% % % 						%Higher deadzone passed from high temperature included
% % % 						%with protection from trespassing 2 deadzones
% % % 						
% % % 						pid.DeadzoneT = pid.FakeDeadzoneT;
% % % 						
% % % 					elseif (pid.afMeasuredValues(pid.iteration - 1) <= pid.SetpointT + pid.RealDeadzoneT) && (pid.afMeasuredValues(pid.iteration) >= pid.SetpointT + pid.RealDeadzoneT) && (pid.DeadzoneT == pid.RealDeadzoneT)
% % % 						
% % % 						%Higher deadzone passed from low temperature included
% % % 						%with protection from trespassing 2 deadzones
% % % 						
% % % 						pid.DeadzoneT = pid.FakeDeadzoneT;
% % % 						
% % % 					elseif (pid.afMeasuredValues(pid.iteration - 1) >= pid.SetpointT - pid.RealDeadzoneT) && (pid.afMeasuredValues(pid.iteration) <= pid.SetpointT - pid.RealDeadzoneT) && (pid.DeadzoneT == pid.RealDeadzoneT)
% % % 						
% % % 						%Lower deadzone passed from high temperature included
% % % 						%with protection from trespassing 2 deadzones
% % % 						
% % % 						pid.DeadzoneT = pid.FakeDeadzoneT;
% % % 						
% % % 					elseif (pid.afMeasuredValues(pid.iteration - 1) <= pid.SetpointT - pid.RealDeadzoneT) && (pid.afMeasuredValues(pid.iteration) >= pid.SetpointT - pid.RealDeadzoneT) && (pid.DeadzoneT == pid.RealDeadzoneT)
% % % 						
% % % 						%Lower deadzone passed from low temperature included
% % % 						%with protection from trespassing 2 deadzones
% % % 						
% % % 						pid.DeadzoneT = pid.FakeDeadzoneT;
% % % 						
% % % 					elseif (pid.afMeasuredValues(pid.iteration - 1) >= pid.SetpointT + pid.DeltaDeadzoneT) && (pid.afMeasuredValues(pid.iteration) <= pid.SetpointT + pid.DeltaDeadzoneT) && (pid.DeadzoneT == pid.FakeDeadzoneT)
% % % 						
% % % 						%Fake Setpoint + delta passed from high temperature
% % % 						%included with protection from trespassing 2 deadzones
% % % 						
% % % 						pid.DeadzoneT = pid.RealDeadzoneT;
% % % 						
% % % 						%We also reset the integral parts
% % % 						
% % % 						pid.intErrorC = 0;
% % % 						pid.intErrorH = 0;
% % % 						
% % % 					elseif (pid.afMeasuredValues(pid.iteration - 1) <= pid.SetpointT - pid.DeltaDeadzoneT) && (pid.afMeasuredValues(pid.iteration) >= pid.SetpointT + pid.DeltaDeadzoneT) && (pid.DeadzoneT == pid.FakeDeadzoneT)
% % % 						
% % % 						%Fake Setpoint - delta passed from low temperature included
% % % 						%with protection from trespassing 2 deadzones
% % % 						
% % % 						pid.DeadzoneT = pid.RealDeadzoneT;
% % % 						
% % % 						%We also reset the integral parts
% % % 						
% % % 						pid.intErrorC = 0;
% % % 						pid.intErrorH = 0;
% % % 						
% % % 					end
% % % 					
% % % 					%CO2 deadzone and setpoint case
% % % 					
% % % 					if (pid.afMeasuredCO2Values(pid.iteration -1) >= pid.CO2Setpoint + pid.CO2RealDeadzone) && (pid.afMeasuredCO2Values(pid.iteration) <= pid.CO2Setpoint + pid.CO2RealDeadzone) && (pid.CO2Deadzone == pid.CO2RealDeadzone)
% % % 						
% % % 						%Deadzone passed from high temperature included
% % % 						%with protection from trespassing 2 deadzones
% % % 						
% % % 						pid.CO2Deadzone = pid.CO2FakeDeadzone;
% % % 						
% % % 					elseif (pid.afMeasuredCO2Values(pid.iteration -1) <= pid.CO2Setpoint + pid.CO2RealDeadzone) && (pid.afMeasuredCO2Values(pid.iteration) >= pid.CO2Setpoint + pid.CO2RealDeadzone) && (pid.CO2Deadzone == pid.CO2RealDeadzone)
% % % 						
% % % 						%Deadzone passed from low temperature included
% % % 						%with protection from trespassing 2 deadzones
% % % 						
% % % 						pid.CO2Deadzone = pid.CO2FakeDeadzone;
% % % 						
% % % 					elseif (pid.afMeasuredCO2Values(pid.iteration -1) >= pid.CO2Setpoint + pid.CO2DeltaDeadzone) && (pid.afMeasuredCO2Values(pid.iteration) <= pid.CO2Setpoint + pid.CO2DeltaDeadzone) && (pid.CO2Deadzone == pid.CO2FakeDeadzone);
% % % 						
% % % 						%Setpoint + delta passed from high temperature included
% % % 						%with protection from trespassing 2 deadzones
% % % 						
% % % 						pid.CO2Deadzone = pid.CO2RealDeadzone;
% % % 						
% % % 					end
% % % 				end
% % % 
% % % 				%Heating phase
% % % 				
% % % 				if pid.aiCurrentTemp < pid.SetpointT - pid.DeadzoneT
% % % 					
% % % 					%PI controller with Anti Windup and movable deadzones
% % % 					
% % % 					pid.errorH = pid.SetpointT - pid.aiCurrentTemp;
% % % 					pid.intErrorH = pid.intErrorH + pid.errorH;
% % % 					pid.outputH = pid.PgainT*(pid.errorH + pid.actTime*pid.intErrorH/pid.intTimeT); %Discretisation Ts*sum(e(t))
% % % 					
% % % 					if pid.outputH > 1 || pid.aiCurrentTemp < pid.SetpointT - pid.ComfortT
% % % 						
% % % 						pid.outputH = 1;
% % % 						pid.intErrorH = pid.intErrorH - pid.errorH;%Saturated -> Anti Windup
% % % 						
% % % 					elseif pid.outputH < 0
% % % 						pid.outputH = 0;
% % % 						pid.intErrorH = pid.intErrorH - pid.errorH;%Saturated -> Anti Windup
% % % 					end
% % % 					
% % % 					
% % % 					
% % % 					%Cooling phase
% % % 					
% % % 				elseif pid.aiCurrentTemp >  pid.SetpointT + pid.DeadzoneT
% % % 					
% % % 					%PI controller with Anti Windup and movable deadzones
% % % 					
% % % 					pid.errorC = pid.aiCurrentTemp - pid.SetpointT;
% % % 					pid.intErrorC = pid.intErrorC + pid.errorC;
% % % 					pid.outputC = pid.PgainT*(pid.errorC + pid.actTime*pid.intErrorC/pid.intTimeT);
% % % 					
% % % 					if pid.outputC > 1 || pid.aiCurrentTemp > pid.SetpointT + pid.ComfortT
% % % 						
% % % 						pid.outputC = 1;
% % % 						pid.intErrorC = pid.intErrorC - pid.errorC;%Saturated -> Anti Windup
% % % 						
% % % 					elseif pid.outputC < 0
% % % 						
% % % 						pid.outputC = 0;
% % % 						pid.intErrorC = pid.intErrorC - pid.errorC;%Saturated -> Anti Windup
% % % 					end
% % % 				end
% % % 				
% % % 				%Venting phase(For CO2)
% % % 				
% % % 				%P controller with movable deadzones
% % % 				
% % % 				pid.CO2Error = pid.aiCurrentCO - pid.CO2Setpoint;
% % % 				
% % % 				if pid.aiCurrentCO > pid.CO2Setpoint + pid.CO2Deadzone
% % % 					
% % % 					%Calculates the control output
% % % 					
% % % 					pid.CO2Output = (pid.hilimit + pid.lolimit)/2 + ((pid.hilimit - pid.lolimit)/2)*sin(pi*pid.CO2Gain*pid.CO2Error);
% % % 					
% % % 					if pid.aiCurrentCO > pid.CO2max || pid.CO2Output > 1
% % % 						
% % % 						pid.CO2Output = 1;
% % % 						
% % % 					elseif pid.aiCurrentCO < pid.CO2Setpoint
% % % 						pid.CO2Output = 0;
% % % 					end
% % % 				else
% % % 					%Nothing is done in the deadzone
% % % 					pid.CO2Output = 0;
% % % 				end
% % % 				
% % % 				%Venting phase(For temperature)
% % % 				%P controller with movable deadzones
% % % 				
% % % 				if pid.aiCurrentTemp > pid.SetpointT + pid.DeadzoneT
% % % 					
% % % 					%pid.outputV = pid.hilimit;
% % % 					
% % % 					pid.errorV = pid.aiCurrentTemp - pid.SetpointT;
% % % 					pid.outputV = (pid.hilimit + pid.lolimit)/2 + ((pid.hilimit - pid.lolimit)/2)*sin(pi*pid.errorV/pid.propband); %Almost as in IDA
% % % 					
% % % 					if pid.aiCurrentTemp > pid.SetpointT + pid.ComfortT || pid.outputV > pid.hilimit
% % % 						pid.outputV = pid.hilimit;
% % % 					elseif pid.outputV < pid.CO2Output
% % % 						pid.outputV = pid.CO2Output;%We prioritize the CO2 level and has the CO2 output as the lowest venting output
% % % 					end
% % % 				else
% % % 					pid.outputV = pid.CO2Output;
% % % 				end
% % % 				
% % % 				if pid.outputV < pid.outputC
% % % 					pid.outputV = pid.outputC; %Avoids stable points above setpoint
% % % 				end
% % % 				
% % % 				%Control output to be actuated
% % % 				
% % % 				pid.outputV = floor(100*pid.outputV);
% % % 				pid.outputC = floor(100*pid.outputC);
% % % 				pid.outputH = floor(100*pid.outputH);
% % % 				
% % % 				%Checks if we have a larger increase or decrease than the rate limit
% % % 				%and if so limits the change of output to the specified
% % % 				%rate limit
% % % 				%Anti windup is not needed since this case only exists when
% % % 				%passing setpoints or deadzones and there anti windup is
% % % 				%already active.
% % % 				
% % % 				if pid.outputV - pid.ControlOutput(1) > pid.RateLimit
% % % 					pid.outputV = pid.ControlOutput(1) + pid.RateLimit;
% % % 				elseif pid.outputV - pid.ControlOutput(1) < -pid.RateLimit
% % % 					pid.outputV = pid.ControlOutput(1) - pid.RateLimit;
% % % 				end
% % % 				
% % % 				if pid.outputC - pid.ControlOutput(2) > pid.RateLimit
% % % 					pid.outputC = pid.ControlOutput(2) + pid.RateLimit;
% % % 				elseif pid.outputC - pid.ControlOutput(2) < -pid.RateLimit
% % % 					pid.outputC = pid.ControlOutput(2) - pid.RateLimit;
% % % 				end
% % % 				
% % % 				if pid.outputH - pid.ControlOutput(3) > pid.RateLimit
% % % 					pid.outputH = pid.ControlOutput(3) + pid.RateLimit;
% % % 				elseif pid.outputH - pid.ControlOutput(3) < -pid.RateLimit
% % % 					pid.outputH = pid.ControlOutput(3) - pid.RateLimit;
% % % 				end
% % % 				
% % % 				pid.ControlOutput = [pid.outputV pid.outputC pid.outputH];
% % % 				disp(['Venting percentage: ' num2str(pid.outputV)]);
% % % 				disp(['Cooling percentage: ' num2str(pid.outputC)]);
% % % 				disp(['Heating percentage: ' num2str(pid.outputH)]);
% % % 				
% % % 				%Sections that is used for the plotting sequence
% % % 				
% % % 				pid.afActuationsC(length(pid.afActuationsC) + 1) = pid.outputC;
% % % 				pid.afActuationsV(length(pid.afActuationsV) + 1) = pid.outputV;
% % % 				pid.afActuationsH(length(pid.afActuationsH) + 1) = pid.outputH;
% % % 				pid.DeadzoneTPlot(pid.iteration)  = pid.DeadzoneT;
% % % 				pid.CO2DeadzonePlot(pid.iteration) = pid.CO2Deadzone;
% % % 				pid.SetpointTPlot(pid.iteration) = pid.SetpointT;
% % % 				pid.CO2SetpointPlot(pid.iteration) = pid.CO2Setpoint;
% % % 				
% % % 			catch exception
% % % 				pid.AddError( strcat('PIDController.ComputeControlInputs: ', exception.message) );
% % % 			end
% % % 		end
		
% % % 		function pid = ComputeFeedback( pid )
% % % 			
% % % 			try
% % % 				
% % % 				achLocation = 'LB201_A225';
% % % 				fAction = [pid.ControlOutput(1) pid.ControlOutput(1) pid.ControlOutput(3) pid.ControlOutput(2)];
% % % 				fAction(3) = 0; %Hardcoded no radiator works
% % % 				
% % % 				for i = 1:4
% % % 					
% % % 					pid.tTCPConnection.SetDataPLC(	pid.ActuatorSignalID(i),	...
% % % 						achLocation,					...
% % % 						fAction(i) );
% % % 					
% % % 				end
% % % 				
% % % 			catch exception
% % % 				pid.AddError( strcat('PIDController.ComputeFeedback: ', exception.message) );
% % % 			end
% % % 		end
		
% 		function PlotResults( pid )
% 			
% 			figure;
% 			
% 			subplot(2, 3, 1),	plot(pid.actTime*((0:length(pid.afMeasuredValues) -1)) ,pid.afMeasuredValues, 'b'),	title(strcat('Measured Values of Temperature'))
% 			
% 			hold on;  plot(pid.actTime*((0:length(pid.DeadzoneTPlot) -1)) ,pid.SetpointTPlot + pid.DeadzoneTPlot, 'g'),...
% 				
% 			plot(pid.actTime*((0:length(pid.DeadzoneTPlot) -1)) ,pid.SetpointTPlot - pid.DeadzoneTPlot, 'g'), ...
% 
% 			plot(pid.actTime*((0:length(pid.DeadzoneTPlot) -1)) ,pid.SetpointTPlot , 'r')
% 			ylabel('Temperature (C)');
% 			xlabel('Time (s)');
% 
% 			legend('Temperature','Deadzone','Deadzone','Reference point');
% 			hold off;
% 
% 			subplot(2, 3, 3),   plot(pid.actTime*((0:length(pid.afMeasuredCO2Values) -1)) ,pid.afMeasuredCO2Values, 'b'),   title(strcat('Measured Values of CO2'))
% 
% 			hold on;  plot(pid.actTime*((0:length(pid.CO2DeadzonePlot) -1)), pid.CO2SetpointPlot + pid.CO2DeadzonePlot, 'g'),...
% 
% 			plot(pid.actTime*((0:length(pid.CO2DeadzonePlot) -1)) , pid.CO2SetpointPlot , 'r')
% 			ylabel('CO2 (ppm)');
% 			xlabel('Time (s)');
% 
% 			legend('CO2','Deadzone','Reference point');
% 			hold off;
% 
% 			subplot(2, 3, 4),	plot(pid.actTime*((0:length(pid.afActuationsC) -1)) ,pid.afActuationsC, 'r'),		title(strcat('Actuated Values of Cooling'))
% 			ylabel('Actuation (%)');
% 			xlabel('Time (s)');
% 
% 			subplot(2, 3, 5),	plot(pid.actTime*((0:length(pid.afActuationsC) -1)) ,pid.afActuationsV, 'r'),		title(strcat('Actuated Values of Ventilation'))
% 			ylabel('Actuation (%)');
% 			xlabel('Time (s)');
% 
% 			subplot(2, 3, 6),	plot(pid.actTime*((0:length(pid.afActuationsC) -1)) ,pid.afActuationsH, 'r'),		title(strcat('Actuated Values of Heating'))
% 			ylabel('Actuation (%)');
% 			xlabel('Time (s)');
% 
% 		end
	end
	
	methods(Access = 'private')
		
	end
	
end


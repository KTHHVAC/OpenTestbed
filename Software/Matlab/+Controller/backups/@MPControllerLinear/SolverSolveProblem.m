 % Solve the problem min C´u
 function SolverSolveProblem( tController)
    %===============================================================================
    % Authors:   Ferran Montes, KTH, Royal Institute of Technology
    % (26-02-2013: first implementation)
    %===============================================================================

	try
		switch tController.strSolver
			case Controller.Solvers.cplex
 
        		[ tController.tSolver.afXmin,			... 
				  tController.tSolver.fFmin,			...
				  tController.tSolver.iSolverStatus,	...
				  tController.tSolver.output ] = cplexlp ( tController.tCost.afCoefficientsOfLinearCostFunction,			 ...
														tController.tConstraints.aafLeftConstrCoef,  ...
														tController.tConstraints.afRightConstrCoef,  ...
														[] ,                                 ...
														[] ,				                 ...	% Quadratic constraints not supported
														tController.tCost.afLowerBound,				 ...
														tController.tCost.afUpperBound,				 ...
														[] );

                                                   

% 				[ tController.tSolver.afXmin,			... 
% 				  tController.tSolver.fFmin,			...
% 				  tController.tSolver.iSolverStatus,	...
% 				  tController.tSolver.strDetails ] = cplexlp ( tController.tCost.afCoefficientsOfLinearCostFunction,			 ...
% 														tController.tConstraints.aafLeftConstrCoef,  ...
% 														tController.tConstraints.afRightConstrCoef,  ...
% 														tController.tConstraints.aiEqConstrIndex,    ...
% 														[] ,				                 ...	% Quadratic constraints not supported
% 														tController.tCost.afLowerBound,				 ...
% 														tController.tCost.afUpperBound,				 ...
% 														tController.tCost.achCPLEXVarType,			 ...
% 														tController.tSolverSettings.tCPLEXParameters, ...
% 														tController.tSolverSettings.tCPLEXOptions );
													
			otherwise
				tController.AddError( 'MPControllerLinear.SolverSolveProblem: Solver selected not supported' );
        end

         %ALESSANDRA: to check
        
% 		if strcmp(tController.strConstraintsType, 'equality')
% 			iIndex  = 1;
% 			iIndexX = 1;
% 			iIndexU = 1;
% 			iNVariables = tController.tModel.iNx + tController.tModel.iNu;
% 			afOptimizedX = zeros(1, tController.tModel.iNx * tController.iPredictionHorizon);
% 			afOptimizedU = zeros(1, tController.tModel.iNu * tController.iPredictionHorizon);
% 			for i = 1 : tController.iPredictionHorizon
% 				for j = 1 : iNVariables
% 					if j < tController.tModel.iNx
% 						afOptimizedX(iIndexX) = tController.tSolver.afXmin(iIndex);
% 						iIndexX = iIndexX + 1;
% 
% 					elseif ((j > tController.tModel.iNx) && (j < tController.tModel.iNx + tController.tModel.iNu))
% 						afOptimizedU(iIndexU) = tController.tSolver.afXmin(iIndex);
% 						iIndexU = iIndexU + 1;
% 
% 					end
% 					iIndex = iIndex + 1;
% 
% 				end
% 
% 			end
% 
% 			tController.tSolver.afXmin = [afOptimizedX, afOptimizedU];
% 		end

		% Check KKT conditons
		% Check the quality of the solution: ( status ~= 6 ) & ( status ~= 5 ) added to 
		% keep simulating in "non-optimal" case
		if ( tController.tSolver.output.cplexstatus ~= 1 ) && ( tController.tSolver.output.cplexstatus ~= 6 ) && ( tController.tSolver.output.cplexstatus ~= 5 )
			tController.AddError( strcat('MPControllerLinear.SolverSolveProblem: Optimization failed: ', tController.tSolver.output.cplexstatus )); 
        end

       
        
% 		% Test if the solution is optimal and CPLEX is just being picky
% 		%in case of non-optimal solution or in case of optimal solution with 
% 		% unscaled infeasibility
% 		switch( tController.tSolver.iSolverStatus )
% 			%
% 			% -------------------------------------------------------------
% 			case {1}
% 			%Do nothing
% 			%
% 			% -------------------------------------------------------------
% 			case {5, 6}
% 				%
% 				ISZEROROUGH = 1e-3;
% 				%
% 				% Primal feasibility
% 				slack = tController.tConstraints.afRightConstrCoef - tController.tConstraints.aafLeftConstrCoef * tController.tSolver.afXmin;
% 				if min(slack) < -ISZEROROUGH, 
% 					tController.AddError('MPControllerLinear.SolverSolveProblem: Solution is primal infeasible');
% 				end
% 				%
% 				%   % Primal equalities
% 				%   if abs(slack(1:nEq)) > ISZEROROUGH, 
% 				%     error('Solution does not satisfy equations'); end
% 				%
% 				% Dual feasibility
% 				if max(tController.tSolver.lambda) > ISZEROROUGH, 
% 					warning( '\n  -- %s', 'Solution is non-optimal' );
% 				end
% 				%
% 				% Complementarity
% 				if abs(slack' * tController.tSolver.lambda) > ISZEROROUGH, 
% 					warning( '\n  -- %s','Solution is non-optimal' );
% 				end
% 				%
% 				% fprintf(' -> CPLEX returned a non-optimal warning, but the solution is optimal to reasonable precision\n');
% 			%
% 			% -------------------------------------------------------------
% 			otherwise
% 				%
% 				warning('The solver exited in an unexpected way');
% 			%
% 		end;% switch
		%
		%
	catch exception
		tController.AddError( strcat('MPControllerLinear.SolverSolveProblem: ', exception.message ));

	end
end
% Compute the inputs over the prediction horizon
%
% ALGORITHM
% - 
%
function ComputeControlInputs( tController )
	%
	%
	try %
		if( tController.bPrintDebugInformation )
			%
			fprintf('Entering ComputeControlInputs()\n');
			%
		end;%
		%
		%
		% TODO: only for the temperature model?
		global VentLowerBound
		tController.ModelGenerateConstantsBatch();
		tController.ExtractSpecificMeasurements();	% Gets the afX0 and other needed measurements
		tController.ExtractSpecificForecasts();		% Gets the afW and renews the bounds for both models
		%
		%
		% if the controller controls the temperature, then he needs to have
		% a lower bound on the ventilation levels
		if tController.ControlledVariable == Controller.Variables.Temperature
			%
			tController.tModel.LowerBound    = VentLowerBound;
			%
			% TODO:check this later
			tController.tModel.FirstLBUH = 0;%tController.tModel.LowerBound *(tController.tModel.fTai - tController.tModel.fRoomTemp);
			tController.tModel.FirstLBUC = 0;%tController.tModel.LowerBound *(tController.tModel.fRoomTemp - tController.tModel.fTai);
			%
		end;% set lower bound on ventilation level
		%
		%
		% construct the matrices that are needed by the MPC
		if strcmp(tController.strConstraintsType, 'inequality')
			% Initializes the matrixes for the mathematical model taking int account if
			% the controller will use only inequality constraints, optimizing U:
			% X = Sx * Xo + Su * U + Se * W
			% Y = C * X = C*Sx * Xo + C*Su * U + C*Se * W
			% C*Su <= Y - C*Sx * X0 - C*Se * W
			tController.ConstraintsSetInequality();
			%
		elseif strcmp(tController.strConstraintsType, 'equality')
			% or it will also use equality constraints for the model states optimizing U,X:
			% X(k+1) = A * X(k) + B * U(k) + E * W(k)
			% Y = C * X = C*A * X(k) + C*B * U(k) + C*E * W(k)
			% C*B, C*-A = C*X + C*E * W(k)
			tController.ConstraintsSetEquality();
			%
		else%
			%
			tController.AddError('MPControllerLinear.ComputeControlInputs: Constraints type not supported');
			%
		end;% construction of the matrices needed by the MPC solver
		%
		%
		% if there are no errors, then solve the MPC problem
		if( tController.GetErrorNumber() == 0 )
			%
			% call the solver
			% CPLEX units           B(1,i)
			% Uh = mvent*Ath [(kg*C)/s] * (1/kg) = C/s
			% Uc = mvent*Atc [(kg*C)/s] * (1/kg) = C/s
			% Atrad = Atrad  [C]		* (1/s)  = C/s
			SolverSetCostFunction( tController );
			SolverSetSettings( tController );
			SolverSolveProblem( tController );
			%
			%
			% save the results
			if( tController.tSolver.iSolverStatus == 1 )
				%
				% Get the solution for the first step
				tController.afNewAction = tController.tSolver.afXmin( 1 : tController.tModel.iNu, 1 )';			
				%
			else%
				%
				% Display the error
				Controller.ProcessCplexExitStatus( tController.tSolver.iSolverStatus );
				%
			end;% if the solver has errors
			

			% save all the solutions
			j = 1;
			iXPosition = size(tController.tData.afOutputVariable, 1) + 1;
			for i = 1 : tController.tModel.iNu : size(tController.tSolver.afXmin, 1)
				tController.tData.afOutputVariable{iXPosition, j} = tController.tSolver.afXmin(i : i+tController.tModel.iNu-1, 1)';
				j = j + 1;
			end
			%
			% Post Processing Phase
			if( tController.ControlledVariable == Controller.Variables.CO2 )
				%
				tController.atStatesSignals(1).Insert(tController.afNewAction);
                
                %check this if...end
                VentLowerBound = 0;
                if( tController.tModel.afX0 > 0 )
					%
                    VentLowerBound = tController.afNewAction / tController.tModel.afX0 ;
					%
				end;%
                
				tController.atStatesSignals(2).Insert(VentLowerBound);

				%
			elseif tController.ControlledVariable == Controller.Variables.Temperature
				%
				%The Uh in the temperature model
				tController.tData.fUHeat		= tController.afNewAction(1, 1); % C/s
				%The Uc in the temperature model
				tController.tData.fUCool		= tController.afNewAction(1, 2); % C/s
				%Trad is the radiator temperature
				tController.tData.fTrad			= tController.afNewAction(1, 3); % C/s
				%
				[tController.tData.fPostTsa, tController.tData.fPostmVent,tController.tData.fPostTrad ] =	...
					Postprocessing(	tController.tData.fUCool , tController.tData.fUHeat,					...
					tController.tData.fTrad - tController.tModel.fRoomTemp,									...
					VentLowerBound,  tController.tModel.fTai,  tController.tModel.fRoomTemp  );
				%
				fVentingPercentage = MassFlowToVentingPercentage(tController.tData.fPostmVent, 'T' );
				%
				tController.tData.fVentingPercentage = fVentingPercentage;
				%Saving into signals
				tController.atStatesSignals(1).Insert(tController.tData.fPostTsa);
				tController.atStatesSignals(2).Insert(tController.tData.fPostmVent);
				tController.atStatesSignals(3).Insert(tController.tData.fPostTrad);
				tController.atStatesSignals(4).Insert(tController.tData.fUHeat);
				tController.atStatesSignals(5).Insert(tController.tData.fUCool);
				tController.atStatesSignals(6).Insert(tController.tData.fVentingPercentage);



				tController.atActuationsSignals(1).Insert(fVentingPercentage);
				tController.atActuationsSignals(2).Insert(fVentingPercentage);
				fprintf('Actuating venting %d \n', fVentingPercentage);


				tController.tModel.fTempTsa			= []; % Needed in MPCCooling
				tController.tModel.fTempCalculatedACPercentage = [];

			end
			%
		else%
			%
			% here we manage the case where the controller has some errors
			warning('the controller has not computed the MPC solution because there are some to be better described errors');
			%
		end;% if there are errors in the controller
		%
	catch exception
		%
		disp(exception.message);
		warning('Error in ComputeControlInputs for MPControllerLinear');
		%
	end;% catch
	%
end % function


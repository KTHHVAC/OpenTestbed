	function SetExplicitMPCProblem( tController )
	%Setting all the matrices of the linear time inveriant discrete model
	%
	try %
		%
		iNumberOfInputs		= size(tController.tModel.aafB,2);
		iNumberOfOutputs	= size(tController.tModel.afC,1);
		iHorizonLength		= tController.iPredictionHorizon;		% to do rimuovi sto tparameter
		%------------------------------------------------------------------
		% setup the problem
		%
		x0  = sdpvar(2,1);
		u	= sdpvar(repmat(iNumberOfInputs,	iHorizonLength, 1), ones(iHorizonLength,1));
		eps = sdpvar(repmat(iNumberOfOutputs,	iHorizonLength, 1), ones(iHorizonLength,1));
		%
		aafA		=	tController.tModel.aafA;
		aafB		=	tController.tModel.aafB;
		afC			=	tController.tModel.afC;
		%
		afBMix		=	tController.tModel.afBMixed;
		afBuMin		=	tController.tInputsBounds.afBuMin;
		afBuMax		=	tController.tInputsBounds.afBuMax;
		afByMin		=	tController.tOutputsBounds.fLowerBound;
		afByMax		=	tController.tOutputsBounds.fUpperBound;
		aafGu		=	tController.tModel.aafGu;
		aafGuMix	=	tController.tModel.aafGuMix;
		aafGxMix	=	tController.tModel.aafGxMix;
		aafW		=	tController.tModel.aafMixedDisturbancesStocastic;
		%
		afLinCost	=	tController.afLinearCostMatrix;
		%
		frho		=	tController.fRhoSoftConstraintsWeight;
		%
		constraints = [];
		objective = 0;
		x = x0;
		%
		for k = 1:iHorizonLength
				x			=	aafA * x	+ aafB		* u{k}	+ aafW(:,k) ;
				objective	=	objective	+ afLinCost * u{k}	+ frho	*	eps{k};
				constraints =	[	constraints,														...
									afByMin - eps{k}				<= afC * x	<= afByMax + eps{k},	...
									afBuMin							<= u{k}		<= afBuMax ,			...
									aafGu*u{k}						<= zeros(4,1),						...
									aafGuMix * u{k} + aafGxMix * x	<= afBMix,							...
									eps{k}							>= 0 ];
		end
		%
		tController.tConstraints	=	constraints;
		tController.tObjective		=	objective;
		tController.tx0				=	x0;
		%
		%
	catch exception
		%
		disp(exception.message);
		warning('Problems computing the control inputs.');
		%
	end;% end catch		
	%
end % end function

		
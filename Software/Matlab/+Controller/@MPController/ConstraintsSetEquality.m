% Build the equality constraint matrices over the prediction horizon
% Constraint function is Gxu*[U:X] = fxu + Gw*W
function ConstraintsSetEquality( obj )
    %===============================================================================
    % Authors:   Ferran Montes, KTH, Royal Institute of Technology
    % (18-04-2013: first implementation)
    %===============================================================================

	try
		switch obj.ControlledVariable
			case Controller.Variables.Temperature
				% Bounds for Temperature controller
				Bound_room

				% TODO: Implement upper and lower bounds switching
				fUBy = UBy_room(1);
				fLBy = LBy_room(2);

				fUBu = UBu_room;
				fLBu = LBu_room;

			case Controller.Variables.CO2
				% Bounds for CO2 controller
				Bound_CO2;
				
				fUBy = UBy_CO2;
				fLBy = LBy_CO2;

				% TODO: Implement upper and lower bounds switching
				fUBu = repmat(UBu_CO2, [obj.tModel.iNu, 1]);
				fLBu = repmat(LBu_CO2, [obj.tModel.iNu, 1]);

			otherwise
				obj.addError( 'MPContrller.ConstraintsSetEquality: Controlled variable not supported' );

		end

		% Set the constraints
		% Gxu*[U:X] = fxu + Gw*W
		% aafGx -> only A*x(0) needed
		for i = 2 : obj.iPredictionHorizon
			obj.tModel.aafSx{i, 1} = zeros(obj.tModel.iNx, obj.tModel.iNx);
		end
		aafGx = cell2mat(obj.tModel.aafSx) * obj.fInitialValue;
		aafGe = cell2mat(obj.tModel.aafSe) * obj.tModel.afW;
		aafGu = eye(obj.tModel.iNx + obj.tModel.iNu); % 16x16 (13x + 3u)

		% fill bound matrix for Y and U
		for i = 1 : obj.tModel.iNx + obj.tModel.iNu
			for j = 1 : obj.tModel.iNx + obj.tModel.iNu
				if i == j && j < obj.tModel.iNu
					aafGu(i, j) = 1;
				end
				if i == j && j > obj.tModel.iNu
					aafGu(i, j) = obj.tModel.aafC(i - obj.tModel.iNu);
				end
			end
		end

		% Left-side constraint matrix (m x n), m = 3
		aafPositiveGxu = cell(obj.iPredictionHorizon, obj.iPredictionHorizon);
		for i = 1 : obj.iPredictionHorizon
			for j = 1 : obj.iPredictionHorizon
				aafPositiveGxu{i, j} = zeros(obj.tModel.iNx + obj.tModel.iNu, obj.tModel.iNx + obj.tModel.iNu);
				if i == j
					aafPositiveGxu{i, j} = aafGu;
				end
			end
		end
		aafPositiveGxu = cell2mat(aafPositiveGxu);

		aafEqualityConstraintU = cell(obj.iPredictionHorizon * obj.iPredictionHorizon);
		aafEqualityConstraintX = cell(obj.iPredictionHorizon * obj.iPredictionHorizon);
		for i = 1 : obj.iPredictionHorizon
			for j = 1 : obj.iPredictionHorizon
				% initially fill with zeros
				aafEqualityConstraintU{i, j} = zeros(size(obj.tModel.aafB));
				aafEqualityConstraintX{i, j} = zeros(size(obj.tModel.aafA));
				if i == j
					% eye of eyes
					aafEqualityConstraintU{i, j} = - obj.tModel.aafB;
					aafEqualityConstraintX{i, j} =   eye(obj.tModel.iNx);
				elseif (i > 1) && (i == j + 1)
					aafEqualityConstraintX{i, j} = - obj.tModel.aafA * eye(obj.tModel.iNx);
				end
				
			end
		end
		
		aafLConstrCoef = cell(3, 1);
		aafLConstrCoef{1, 1} =   aafPositiveGxu;
		aafLConstrCoef{2, 1} = - aafPositiveGxu;
		aafLConstrCoef{3, 1} =   [cell2mat(aafEqualityConstraintU), cell2mat(aafEqualityConstraintX)];
		aafLConstrCoef = cell2mat(aafLConstrCoef);

		% Right-side constraint matrix (m x 1)
		aafMaxYU = cell(obj.iPredictionHorizon, 1);
		aafMinYU = cell(obj.iPredictionHorizon, 1);
		for i = 1 : obj.iPredictionHorizon
			aafMaxYU{i, 1} =   [fUBu; repmat(fUBy, [obj.tModel.iNx, 1])];
			aafMinYU{i, 1} = - [fLBu; repmat(fLBy, [obj.tModel.iNx, 1])];
		end
		aafMaxYU = cell2mat(aafMaxYU);
		aafMinYU = cell2mat(aafMinYU);

		aafRConstrCoef = cell(3, 1);
		aafRConstrCoef{1, 1} = aafMaxYU;
		aafRConstrCoef{2, 1} = aafMinYU;
		aafRConstrCoef{3, 1} = aafGx + aafGe;
		aafRConstrCoef = cell2mat(aafRConstrCoef);

		% Set the bounds. Included in the constraints
		lBound = [];
		uBound = [];

		% Set function outputs for the linear MPC
		obj.tCost.afLowerBound = lBound;
		obj.tCost.afUpperBound = uBound;

		obj.tConstraints.aafLeftConstrCoef = aafLConstrCoef;
		obj.tConstraints.afRightConstrCoef = aafRConstrCoef;

		% Get the indices of the equality constraints
		iIndex = 0;
		for i = 1 : obj.iPredictionHorizon
			iStartPosition = (i * ((obj.tModel.iNx + obj.tModel.iNu) * 2)) + (obj.tModel.iNx * (i - 1));
			for j = 1 : obj.tModel.iNx
				iIndex = iIndex + 1;
				obj.tConstraints.aiEqConstrIndex(iIndex) = iStartPosition + j;
			end
		end

	catch exception
		obj.AddError( strcat('MPContrller.ConstraintsSetEquality: ', exception.message ));

	end

end


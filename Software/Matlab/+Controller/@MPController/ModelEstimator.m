function ModelEstimator( obj )

	% Inputs
	% Computed output variable
	% afOutputVariable = obj.afOutputVariable(length(obj.afOutputVariable));
	% Measured values
	afMeasuredValues = obj.fInitialValue;
	afOutputValues	 = obj.tData.afOutputVariable;
	afInitialEstimation = afMeasuredValues;

	% Get the eigenvalues of A
	afPoles		= eig(obj.tModel.aafA);
	afPoles_obs	= 1 * afPoles;

	% State-feedback matrix L such that the eigenvalues of A-C*L are those
	% specified in the vector poles_obs
	aafL = acker(obj.tModel.aafA', obj.tModel.aafC', afPoles_obs)';
	 
	XX=afMeasuredValues;
	XXhat=afInitialEstimation;
	T=1;
	UU=afOutputValues{size(afOutputValues, 1), 1}'; % input signal
	
	for k=0:T-1,
		u=UU;
		y=obj.tModel.aafC * afMeasuredValues;
		yhat=obj.tModel.aafC * afInitialEstimation;

		afMeasuredValues=obj.tModel.aafA * afMeasuredValues + obj.tModel.aafB * u; % Originally u, but we only need one evaluation, right?
		afInitialEstimation= obj.tModel.aafA * afInitialEstimation + obj.tModel.aafB * u + aafL * (y-yhat);

		XX=[XX,afMeasuredValues];
		XXhat=[XXhat,afInitialEstimation];
	end
	obj.fInitialValue = XXhat(:,2,end);
end

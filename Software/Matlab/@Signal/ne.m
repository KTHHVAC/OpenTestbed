% notice that tSignalB may be a scalar
%
function tResult = ne( tSignalA, tSignalB )
	%
	if( isa(tSignalB, 'Signal') )
		%
		% resample the signals on the same times
		afUnionOfTimes = sort( unique( [ tSignalA.afTimes ; tSignalB.afTimes ] ) );
		%
		tResampledA = tSignalA.ResampleAt( afUnionOfTimes );
		tResampledB = tSignalB.ResampleAt( afUnionOfTimes );
		%
		% we copy the information of the first signal
		tResult = tSignalA.Copy();
		%
		tResult.afTimes 		= afUnionOfTimes;
		tResult.afValues 		= tResampledA.afValues ~= tResampledB.afValues;
		tResult.afInaccuracies	= max( tResampledA.afInaccuracies, tResampledB.afInaccuracies );
		%
	else%
		%
		tResult = tSignalA.Copy();
		%
		if( numel(tSignalB) ~= 1 )
			%
			warning('~= between signals called in a wrong way! Returning only the first argument');
			%
		else%
			%
			tResult.afValues = +(tResult.afValues ~= tSignalB); % the uplus removes the 'logical' flag
			%
		end;%
		%
	end;%
	%
end % function


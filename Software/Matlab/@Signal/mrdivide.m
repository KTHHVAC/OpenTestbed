% notice that tSignalB may be a scalar
%
function tDivision = mrdivide( tSignalA, tSignalB )
	%
	if( isa(tSignalB, 'Signal') )
		%
		% resample the signals on the same times
		afUnionOfTimes = sort( unique( [ tSignalA.afTimes ; tSignalB.afTimes ] ) );
		%
		tResampledA = tSignalA.ResampleAt( afUnionOfTimes );
		tResampledB = tSignalB.ResampleAt( afUnionOfTimes );
		%
		% we copy the information of the first signal
		tDivision = tSignalA.Copy();
		%
		tDivision.afTimes 			= afUnionOfTimes;
		tDivision.afValues 			= tResampledA.afValues ./ tResampledB.afValues;
		tDivision.afInaccuracies	= max( tResampledA.afInaccuracies, tResampledB.afInaccuracies );
		%
	else%
		%
		tDivision = tSignalA.Copy();
		%
		if( numel(tSignalB) ~= 1 )
			%
			warning('+ between signals called in a wrong way! Returning only the first argument');
			%
		else%
			%
			tDivision.afValues = tDivision.afValues / tSignalB;
			%
		end;%
		%
	end;%
	%
end % function


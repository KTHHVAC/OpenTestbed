% finds the NaNs and interpolates them
%
function InterpolateNaNs( tSignal )
	%
	%
	% case where the signal starts with some NaNs
	if( isnan( tSignal.afValues(1) ) )
		%
		iFirstNotNaNSample = ...
			find( ~isnan( tSignal.afValues ), 1, 'first' );
		%
		% case where there are only NaNs
		if( numel(iFirstNotNaNSample) == 0 )
			%
			% in this case we set the signal equal to zero
			tSignal.afValues		= 0 * tSignal.afValues;
			tSignal.afInaccuracies	= 999 * ones( size(tSignal.afValues) );
			%
			% at this point we must exit otherwise we will enter in the other ifs
			return;
			%
		else%
			%
			tSignal.afValues(1:iFirstNotNaNSample-1) = ...
				tSignal.afValues(iFirstNotNaNSample);
			%
			tSignal.afInaccuracies(1:iFirstNotNaNSample-1) = ...
				abs( tSignal.afTimes(1:iFirstNotNaNSample-1) - tSignal.afTimes(iFirstNotNaNSample) );
			%
			% DEBUG
% 			fprintf('fixed NaNs up to index %d\n', iFirstNotNaNSample-1);
			%
		end;%
		%
	end;%
	%
	%
	% case where the signal ends with some NaNs
	if( isnan( tSignal.afValues(end) ) )
		%
		iLastNotNaNSample = ...
			find( ~isnan( tSignal.afValues ), 1, 'last' );
		%
		tSignal.afValues(iLastNotNaNSample+1:end) = ...
			tSignal.afValues(iLastNotNaNSample);
		%
		tSignal.afInaccuracies(iLastNotNaNSample+1:end) = ...
			abs( tSignal.afTimes(iLastNotNaNSample) - tSignal.afTimes(iLastNotNaNSample+1:end) );
		%
		% DEBUG
% 		fprintf('fixed NaNs from index %d\n', iLastNotNaNSample+1);
		%
	end;%
	%
	%
	% now we can perform some storage allocation
	tSignal.afValues 	= tSignal.afValues;
	%
	%
	% other cases: initialization
	bPreviousSampleWasNaN = false;
	%
	%
	for iSample = 1:numel( tSignal.afValues );
		%
		% for readability
		bCurrentSampleIsNaN = isnan(tSignal.afValues(iSample));
		%
		if(			 bCurrentSampleIsNaN	...
				&&	~bPreviousSampleWasNaN	)
			%
			iBeginningOfIntervalOfNaNs = iSample;
			%
		elseif(		~bCurrentSampleIsNaN	...
				&&	 bPreviousSampleWasNaN	)
			%
			iEndingOfIntervalOfNaNs = iSample;
			%
			% interpolate
			for iInterpolationSample = iBeginningOfIntervalOfNaNs:iEndingOfIntervalOfNaNs;
				%
				% linear interpolation
				%                    f(x_2) - f(x_1)
				% f(x_i) = f(x_1) + ----------------- * (x_i - x_1)
				%                       x_2 - x_1
				%
				tSignal.afValues(iInterpolationSample) =						...
					tSignal.afValues(iBeginningOfIntervalOfNaNs - 1)			...
					+															...
					(															...
						(														...
							tSignal.afValues(iEndingOfIntervalOfNaNs)			...
							-													...
							tSignal.afValues(iBeginningOfIntervalOfNaNs - 1)	...
						)														...
						/														...
						(														...
							tSignal.afTimes(iEndingOfIntervalOfNaNs)			...
							-													...
							tSignal.afTimes(iBeginningOfIntervalOfNaNs - 1)		...
						)														...
					)															...
					*															...
					(															...
						tSignal.afTimes(iInterpolationSample)					...
						-														...
						tSignal.afTimes(iBeginningOfIntervalOfNaNs - 1)			...
					);
				%
				tSignal.afInaccuracies(iInterpolationSample) =							...
					min(	abs(		tSignal.afTimes(iInterpolationSample)			...
									-	tSignal.afTimes(iEndingOfIntervalOfNaNs) ),		...
							abs(		tSignal.afTimes(iInterpolationSample)			...
									-	tSignal.afTimes(iBeginningOfIntervalOfNaNs - 1) ) );
				%
				% DEBUG
%				fprintf('interpolated sample %d, put to %.5f\n', iInterpolationSample, tSignal.afValues(iInterpolationSample));
				%
			end;%
			%
			% reset
			iBeginningOfIntervalOfNaNs	= [];
			%
		end;%
		%
		% save the status
		bPreviousSampleWasNaN = bCurrentSampleIsNaN;
		%
	end;% sample
	%
	%
	% TODO better interpolation schemes
	%
	%
end % function


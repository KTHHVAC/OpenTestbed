% notice that tSignalB may be a scalar
%
function tProduct = mtimes( tSignalA, tSignalB )
	%
	if( isa(tSignalB, 'Signal') )
		%
		% resample the signals on the same times
		afUnionOfTimes = sort( unique( [ tSignalA.afTimes ; tSignalB.afTimes ] ) );
		%
		tResampledA = tSignalA.ResampleAt( afUnionOfTimes );
		tResampledB = tSignalB.ResampleAt( afUnionOfTimes );
		%
		% we copy the information of the first signal
		tProduct = tSignalA.Copy();
		%
		tProduct.afTimes 		= afUnionOfTimes;
		tProduct.afValues 		= tResampledA.afValues .* tResampledB.afValues;
		tProduct.afInaccuracies	= max( tResampledA.afInaccuracies, tResampledB.afInaccuracies );
		%
	else%
		%
		tProduct = tSignalA.Copy();
		%
		if( numel(tSignalB) ~= 1 )
			%
			warning('+ between signals called in a wrong way! Returning only the first argument');
			%
		else%
			%
			tProduct.afValues = tProduct.afValues * tSignalB;
			%
		end;%
		%
	end;%
	%
end % function


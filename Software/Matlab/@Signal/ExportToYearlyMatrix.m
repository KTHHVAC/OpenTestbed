% strModality = 'integrate' | 'sample'
%
% Note: if not given then it is automatically set to 'integrate'
%
function aafMatrix = ExportToYearlyMatrix( tSignal, strModality )
	%
	if( nargin == 1 )
		%
		strModality = 'integrate';
		%
	end;%
	%
	% consistency check
	if( numel( tSignal.afTimes ) == 0 )
		%
		aafMatrix = [];
		warning( 'you are trying to extract information from an empty signal! returning a void matrix' );
		return;
		%
	end;%
	%
	fInitialJulianDate	= tSignal.afTimes(1);
	fFinalJulianDate	= tSignal.afTimes(end);
	%
	% DEBUG
% 	Time.JulianDateToString(fInitialJulianDate)
% 	Time.JulianDateToString(fFinalJulianDate)
	%
	iStartingYear	= Time.JulianDateToYear(fInitialJulianDate);
	iEndingYear		= Time.JulianDateToYear(fFinalJulianDate);
	%
	% compute the number of days of the set of years
	iNumberOfSpannedDays = 0;
	%
	for iYear = iStartingYear:iEndingYear;
		%
		iNumberOfSpannedDays = iNumberOfSpannedDays + Time.NumberOfDaysInYear( iYear );
		%
	end;%
	%
	% start constructing the vector that then will become a matrix
	afVector = NaN( iNumberOfSpannedDays * 24, 1 );
	%
	% fill the vector with the meaningful data
	iInitialHourInYear	= Time.JulianDateToHourOfYear( Time.RoundJulianDateToClosestGregorianHour( fInitialJulianDate ) );
	iFinalHourInYear	= Time.JulianDateToHourOfYear( Time.RoundJulianDateToClosestGregorianHour( fFinalJulianDate ) );
	%
	% manage the case where the simulations span for more than one year
	for iYear = iStartingYear:(iEndingYear-1);
		%
		iFinalHourInYear = iFinalHourInYear + Time.NumberOfDaysInYear( iYear );
		%
	end;%
	%
	switch(strModality)
		%
		%
		% --------------------------------------------------
		case 'sample'
			%
			afSamplingTimes =														...
					Time.GregorianDateToJulianDate( iStartingYear, 1, 1, 0, 30, 0 )	...
				+	( iInitialHourInYear:(iFinalHourInYear-1) ) * Time.GetJulianHour();
			%
			afVector( (iInitialHourInYear+1):(iFinalHourInYear) ) =	...
				tSignal.ExtractSamplesAt( afSamplingTimes );
		%
		%
		% --------------------------------------------------
		case 'integrate'
			%
			afSamplingTimes =														...
					Time.GregorianDateToJulianDate( iStartingYear, 1, 1, 0, 0, 1 )	...
				+	( iInitialHourInYear:iFinalHourInYear ) * Time.GetJulianHour();
			%
			for iHour = (iInitialHourInYear):(iFinalHourInYear-1);
				%
				iTimeIndex = iHour - iInitialHourInYear + 1;
				%
				afVector(iHour + 1) =						...
					tSignal.IntegrateBetween(				...
						afSamplingTimes(iTimeIndex),		...
						afSamplingTimes(iTimeIndex + 1),	...
						'Hours'								);
				%
				% DEBUG
% 				Time.JulianDateToString(afSamplingTimes(iTimeIndex))
% 				Time.JulianDateToString(afSamplingTimes(iTimeIndex + 1))
				%
			end;%
		%
		%
		% --------------------------------------------------
		otherwise
			disp(strModality)
			error('wrong strModality selection');
		%
	end;%
	%
	% DEBUG
% 	Time.JulianDateToString(afSamplingTimes(1))
% 	Time.JulianDateToString(afSamplingTimes(end))
% 	Time.JulianDateToString(afSamplingTimes)
	%
	% reshape the vector into a matrix
	aafMatrix = reshape( afVector, 24, iNumberOfSpannedDays );
	%
	% DEBUG
% 	Time.JulianDateToString( afSamplingTimes )
	%
end % function


% strModality = 'mean' | 'min' | 'max'
%
% 'mean' means that the initial / final dates are the means of the initial /
%        final dates of the various signals
%
% 'min'  means that the time span is the intersection of the timespans
%
% 'max'  means that the time span is the union of the timespans
%
%
function [ fInitialJulianDate, fFinalJulianDate ] = GetTimeSpan( atSignals, strModality )
	%
	%
	if( nargin < 2 )
		%
		strModality = 'max';
		%
	end;%
	%
	%
	switch( strModality )
		%
		case 'min'
			fInitialJulianDate	= -99999999999999999999999999999999999;
			fFinalJulianDate	=  99999999999999999999999999999999999;
		%
		case 'max'
			fInitialJulianDate	=  99999999999999999999999999999999999;
			fFinalJulianDate	= -99999999999999999999999999999999999;
		%
		case 'mean'
			fInitialJulianDate	= 0;
			fFinalJulianDate	= 0;
		%
		otherwise
			error('wrong modality type')
		%
	end;% switch
	%
	%
	for iSignal = 1:numel( atSignals );
		%
		% DEBUG
		fprintf(	'%s -> %s - signal %s\n',										...
					Time.JulianDateToString( atSignals(iSignal).afTimes(1)){1},		...
					Time.JulianDateToString( atSignals(iSignal).afTimes(end)){1},	...
					sprintf('%s', atSignals(iSignal).strDescription )				);
		%
		switch( strModality )
			%
			case 'min'
				fInitialJulianDate	= max( fInitialJulianDate, atSignals(iSignal).afTimes(1) );
				fFinalJulianDate	= min( fFinalJulianDate, atSignals(iSignal).afTimes(end) );
			%
			case 'max'
				fInitialJulianDate	= min( fInitialJulianDate, atSignals(iSignal).afTimes(1) );
				fFinalJulianDate	= max( fFinalJulianDate, atSignals(iSignal).afTimes(end) );
			%
			case 'mean'
				fInitialJulianDate	= fInitialJulianDate + atSignals(iSignal).afTimes(1) / numel( atSignals );
				fFinalJulianDate	= fFinalJulianDate + atSignals(iSignal).afTimes(end) / numel( atSignals );
			%
			otherwise
				error('wrong modality type')
			%
		end;% switch
	   	%
	end;% signal
	%
end %

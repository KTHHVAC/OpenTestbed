% algorithm
%
% - assuming that the data are sorted by time, do a "diff"
%
% - for the zones where the diff is null, check if there are 
%   signal ids that are the same
%
function aafData = RemoveRedundantData( aafRawData )
	%
	global bPrintDebugInformation;
	global tFileID;
	%
	% DEBUG
	if( bPrintDebugInformation )
		%
		fprintf(tFileID, 'Removing the redundant data\n');
		%
	end;%
	%
	if( numel( aafRawData ) == 0 )
		%
		aafData = [];
		return;
		%
	end;%
	%
	% for readability
	SIGNAL_ID_COLUMN	= 1;
	TIME_COLUMN			= 2;
	%
	% for DEBUG purposes
% 	aafRawData =	[	...
% 						1,		9 ;	...
% 						2,		10 ;	...
% 						3,		11 ;	...
% 						3,		11 ;	...
% 						5,		11 ;	...
% 						6,		12 ;	...
% 						7,		13 ;	...
% 						8,		14 ;	...
% 						9,		14 ;	...
% 						10,		15 ;	...
% 						10,		15 ;	...
% 						12,		16 ;	...
% 					];
	%
	% initialization
	aafData = aafRawData;
	%
	% get booleans that say if there are time differences
	abThereAreTimeDifferences = [ ( diff( aafRawData(:, 2) ) > 0 ) ; 1 ];
	%
	% get other booleans, to get when the periods of same
	% time start and end
	afDiffOfThereAreTimeDifferences 			= [ diff( abThereAreTimeDifferences ) ; 0 ];
	abWhereOneStartsPeriodsOfNoTimeDifferences	= [ afDiffOfThereAreTimeDifferences < 0 ];
	abWhereOneExitsPeriodsOfNoTimeDifferences	= [ afDiffOfThereAreTimeDifferences > 0 ];
	%
	% construct a matrix N_periods x 2 with the starting / ending indexes
	aaiIndexesOfInterestingPeriods	=								...
		[															...
			find( abWhereOneStartsPeriodsOfNoTimeDifferences ) + 1,	...
			find( abWhereOneExitsPeriodsOfNoTimeDifferences ) + 1	...
		];
	%
	% if there is no starting / ending indexes then return, delaying the
	% computations to the next round
	if( numel(aaiIndexesOfInterestingPeriods) == 0 )
		%
		aafData = aafRawData;
		return;
		%
	end;%
	%
	% for each period check if there are duplicates
	for iPeriod = 1:numel( aaiIndexesOfInterestingPeriods(:, 1) );
		%
		% for readability
		iStartIndex	= aaiIndexesOfInterestingPeriods(iPeriod, 1);
		iEndIndex	= aaiIndexesOfInterestingPeriods(iPeriod, 2);
		aiListOfDifferentSignalIDs	= unique( aafData( iStartIndex:iEndIndex, SIGNAL_ID_COLUMN ) );
		%
		% DEBUG
		if( bPrintDebugInformation )
		aafData( iStartIndex:iEndIndex, SIGNAL_ID_COLUMN ) 
 		aiListOfDifferentSignalIDs
		end;%
		%
		% do the check only if there is something equal to each other 
		if(	numel(aiListOfDifferentSignalIDs) ~= ( iEndIndex - iStartIndex + 1 ) )
			%
			% for each signal ID, check how many rows in raw data have
			% this signal ID. Then if there is more than one put in all
			% but the first row a nonvalid ID (it is like discarding the datum)
			for iSignalIDIndex = 1:numel(aiListOfDifferentSignalIDs)
				%
				% for readability
				iSignalID = aiListOfDifferentSignalIDs(iSignalIDIndex);
				%
				% find the rows that have this signal ID
				aiRowsWithThisSignalID =		...
					find( aafData( iStartIndex:iEndIndex, SIGNAL_ID_COLUMN ) == iSignalID );
				%
				% if there are more than 1 row with this ID, then discard
				% the oldest ones
				if( numel( aiRowsWithThisSignalID ) > 1 )
					%
					for iRow = 2:numel(aiRowsWithThisSignalID)
						%
						aafData( iStartIndex + aiRowsWithThisSignalID(iRow) - 1, SIGNAL_ID_COLUMN ) = 0;
						%
					end;% cycle on the rows to be 'removed'
					%
				end;% if there are at least one row with this ID
				%
			end;% cycle on the signal IDs
			%
		end;% there is something equal to something else
		%
	end;% cycle on the periods of constant time
	% 
	%
	% DEBUG
	if( bPrintDebugInformation )
		%
		fprintf(tFileID, 'Ended removing the redundant data\n');
		%
	end;%
	%	
end % function


function [ atOccupancyEvents, iEndingTime ] = TransformRawDataIntoEvents( aafRawData, iStartingTime )
	%
	global bPrintDebugInformation;
	global tFileID;
	%
	if( nargin == 1 )
		%
		iStartingTime = 0;
		%
	end;%
	%
	%
	% DEBUG
	if( bPrintDebugInformation )
		%
		fprintf(tFileID, 'Transforming raw data into events, starting time = %d\n', iStartingTime);
		%
	end;%
	%
	% 
	% sort the old data
	aafRawData = Occupancy.SortData( aafRawData, iStartingTime );
	% 
	% delete the old data
	aafRawData = Occupancy.RemoveOldData( aafRawData, iStartingTime );
	% 
	% remove the redundant data (e.g., if there is some repeated key)
	aafRawData = Occupancy.RemoveRedundantData( aafRawData );
	%
	% if the process of removing data has eliminated everything, then
	% return immediately
	if( numel( aafRawData ) == 0 )
		%
		atOccupancyEvents	= [];
		iEndingTime			= iStartingTime;
		%
		if( bPrintDebugInformation )
			%
			fprintf(tFileID, 'All the raw data have been removed, returning no events. Ending time = %d\n', iEndingTime);
			%
		end;%
		%
		return;
		%
	end;%
	% 
	% segmentate the list of raw data events
	[	aiTimesOfBeginningsOfOccupancyEvents,			...
		aiTimesOfEndingsOfOccupancyEvents		]	=	...
			Occupancy.SegmentOccupancyEvents( aafRawData );
	%
	% for readability
	iNumberOfEvents = numel( aiTimesOfBeginningsOfOccupancyEvents );
	%
	% 
	% provide events only if one found them
	if( numel(aiTimesOfEndingsOfOccupancyEvents) > 0 )
		%
		% storage allocation
		atOccupancyEvents(iNumberOfEvents) = Occupancy.OccupancyEvent();
		%
		for iEvent = 1:numel( aiTimesOfBeginningsOfOccupancyEvents )
			%
			% DEBUG
			if( bPrintDebugInformation )
				%
				fprintf(tFileID, 'Starting processing occupancy event %d -- from time %d to time %d\n',	...
						iEvent,																	...
						aiTimesOfBeginningsOfOccupancyEvents( iEvent ),							...
						aiTimesOfEndingsOfOccupancyEvents( iEvent )								);
				%
			end;%
			%
			iStartingIndex	= find( aafRawData(:, 2) == aiTimesOfBeginningsOfOccupancyEvents( iEvent ), 1, 'first' );
			iEndingIndex	= find( aafRawData(:, 2) == aiTimesOfEndingsOfOccupancyEvents( iEvent ), 1, 'last' );
			%
			atOccupancyEvents(iEvent) = Occupancy.OccupancyEvent( aafRawData(iStartingIndex:iEndingIndex, :) ); 
% 			%
% 			% DEBUG
% 			if( bPrintDebugInformation )
% 				%
% 				atOccupancyEvents(iEvent).Plot();
% 				%
% 			end;%			
			%
		end;% cycle on the various events
		% 
	else%
		%
		atOccupancyEvents	= [];
		iEndingTime			= iStartingTime;
		%
		% DEBUG
		if( bPrintDebugInformation )
			%
			fprintf(tFileID, 'No events were found!\n');
			%
		end;%			
		%		
	end;%
	%
	% remove the invalid events
	atOccupancyEvents = Occupancy.DiscardInvalidEvents( atOccupancyEvents );
	%
	% eventually compute the ending time. It must point to the end of the
	% last valid occupancy event that has been saw
	iEndingTime = Occupancy.ComputeEndingTime( atOccupancyEvents, iStartingTime );
	%
	% DEBUG
	if( bPrintDebugInformation )
		%
		fprintf(tFileID, 'Ended transforming raw data into events. Ending time = %d\n', iEndingTime);
		%
	end;%			
	%
end % function


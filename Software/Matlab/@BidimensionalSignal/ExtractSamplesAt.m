% 3d interpolation algorithm:
%
% inputs:
% (x1, y1, z1)
% (x2, y2, z2)
% (x3, y3, z3)
%
% output:
% (xn, yn, zn)
%
% Computation:
% the plane is z = ax + by + c, and (a, b, c) can be computed as the solution of the linear
% system
%
% | x1   y1   1 | | a |     | z1 |
% | x2   y2   1 | | b |  =  | z2 |
% | x3   y3   1 | | c |     | z3 |
%
% that can be rewritten as A \chi = \beta.
%
% Once \chi has been computed, zn can be computed immediately
%
%
% In case the points (x1, y1), (x2, y2), (x3, y3) are not in general
% positions then perform linear interpolation between the two points
% closest to (xn, yn). Assuming that the two closest points are
% (xa, ya, za), (xb, yb, zb), the locus corresponding to the line passing
% through those 2 points is
%
% (xa, ya, za) + t ( (xb, yb, zb) - (xa, ya, za) )
%
% thus one finds t by solving 'xn = xa + t(xb - xa)', and then finds
% zn by solving 'zn = za + t(zb - za)'
%
function afValues = ExtractSamplesAt( tSignal, afSamplingX, afSamplingY )
	%
	% storage allocation
	afValues = zeros( numel( afSamplingX ), 1 );
	%
	% validity check
	if( numel( tSignal.tYSignalsIndexes ) == 0 )
		%
		fprintf('\n\nyou are trying to extract samples from a void signal!!!!\n\n');
		return;
		%
	end;%
	%
	% for each sample perform the 3d interpolation
	for iSample = 1:numel( afSamplingX )
		%
		% get the three closest tripletes (in a sorted way, i.e.,
		% A will be the closest one, B the second, etc.)
		[ afXYZTripleteA, afXYZTripleteB, afXYZTripleteC ] =		...
			tSignal.GetTheThreeTripletesClosestTo( afSamplingX(iSample), afSamplingY(iSample) );
		%
		% if the (xi yi) are not in general positions then do simple 2d linear interpolation
		if( BidimensionalSignal.Are2DPointsInGeneralPositions(	...
				[ afXYZTripleteA(1) ; afXYZTripleteA(2) ],		...
				[ afXYZTripleteB(1) ; afXYZTripleteB(2) ],		...
				[ afXYZTripleteC(1) ; afXYZTripleteC(2) ],		...
				0.000001										) ) % TODO understand how to tune this threshold
			%
			% compute the t
			fT =		( afSamplingX(iSample)	- afXYZTripleteA(1) )	...
					/	( afXYZTripleteB(1)		- afXYZTripleteA(1) );
			%
			% compute the value
			afValues(iSample) = afXYZTripleteA(3) + fT * (afXYZTripleteB(3) - afXYZTripleteA(3));
			%
		else%
			%
			% compute the matrices (for readability)
			aafA =		[	afXYZTripleteA(1),	afXYZTripleteA(2),	1 ;	...
							afXYZTripleteB(1),	afXYZTripleteB(2),	1 ;	...
							afXYZTripleteC(1),	afXYZTripleteC(2),	1 	];
			%
			afBeta =	[	afXYZTripleteA(3) ; ...
							afXYZTripleteB(3) ; ...
							afXYZTripleteC(3)	];
			%
			% solve the linear problem
			afChi = linsolve( aafA, afBeta );
			%
			% then compute the value
			afValues(iSample) =						...
					afChi(1) * afSamplingX(iSample)	...
				+	afChi(2) * afSamplingY(iSample)	...
				+	afChi(3);
			%
		end;% if the (xi yi) are not in general positions
		%
	end;% for on the samples
	%
end % function


% 3d interpolation algorithm:
%
% inputs:
% (x1, y1, z1)
% (x2, y2, z2)
% (x3, y3, z3)
%
% output:
% (xn, yn, zn)
%
% Computation:
% the plane is z = ax + by + c, and (a, b, c) can be computed as the solution of the linear
% system
%
% | x1   y1   1 | | a |     | z1 |
% | x2   y2   1 | | b |  =  | z2 |
% | x3   y3   1 | | c |     | z3 |
%
% that can be rewritten as A \chi = \beta.
%
% Once \chi has been computed, zn follows immediately
%
function [afValues, afInaccuracies] = ExtractSamplesAt( tSignal, afSamplingX, afSamplingY )
	%
	% storage allocation
	afValues		= zeros( numel( afSamplingX ), 1 );
	afInaccuracies	= zeros( numel( afSamplingX ), 1 );
	%
	% validity check
	if( numel( tSignal.tYSignalsIndexes ) == 0 )
		%
		fprintf('\n\nyou are trying to extract samples from a void signal!!!!\n\n');
		return;
		%
	end;%
	%
	% for each sample perform the 3d interpolation
	for iSample = 1:numel( afSamplingX )
		%
		% get the three closest tripletes
		[ afXYZTripleteA, afXYZTripleteB, afXYZTripleteC ] =		...
			tSignal.GetTheThreeTripletesClosestTo( afSamplingX(iSample), afSamplingY(iSample) );
		%
		% if the (xi yi) are not in general positions then do simple 2d linear interpolation
		if( ... )
			%
			%
		end;% if the (xi yi) are aligned
		%
		% compute the matrices (for readability)
		aafA =	...
		%
		afBeta = ...
		%
		% solve the linear problem
		afChi = ...
		%
		
		%
	end;% for on the samples
	%
end % function


% algorithm:
%
% - find the list of x's that are not more far from the desired one of the given radius
% - find the corresponding y signals indexes
% - for each of these signals check which points are not more far from the desired one of the given radius
%
function aafXYZTriplets =					...
			GetTheXYZTripletsInsideTheBall(	...
				tSignal,					...
				fX,							...
				fY,							...
				fRadius						)
	%
	% initialization
	aafXYZTriplets = [];
	%
	% get the x's that are not more far than the radius
	afXsInTheDesiredRange = 				...
		Signal.FindElementsInARange(		...
		tSignal.tYSignalsIndexes.afTimes,	...
		fX - fRadius,						...
		fX + fRadius						);
	%
	% for each x scan the various y's
	for iCurrentXIndex = 1:numel(afXsInTheDesiredRange);
		%
		% for readability
		fCurrentX = afXsInTheDesiredRange(iCurrentXIndex);
		%
		% find the corresponding y signal
		iIndexOfYSignalWithCurrentX = tSignal.tYSignalsIndexes.ExtractSamplesAt(fCurrentX);
		%
		% then find the closest y inside this signal
		afCurrentYsGivenX =													...
			Signal.FindElementsInARange(									...
				tSignal.atYSignals{iIndexOfYSignalWithCurrentX}.afTimes,	...
				fY - fRadius,												...
				fY + fRadius												);
		%
		% for each y check if they are inside 
		for iCurrentYIndex = 1:numel(afCurrentYsGivenX);
			%
			% for readability
			fCurrentY = afCurrentYsGivenX(iCurrentYIndex);
			%
			% for readability
			fCurrentNorm = norm( [fX, fY] - [fCurrentX, fCurrentY] );
			%
			% in case, save the current point
			if( fCurrentNorm <= fRadius )
				%
				% compute the current z
				fCurrentZ = tSignal.atYSignals{iIndexOfYSignalWithCurrentX}.ExtractSamplesAt( fCurrentY );
				%
				aafXYZTriplets(end+1, :) =		...
					[							...
						fCurrentX,				...
						fCurrentY,				...
						fCurrentZ				...
					];
				%
			end;% if the current distance is not bigger than the radius
			%
		end;% cycle on the various ys
		%
	end;% cycle on the various xs
	%
end % function


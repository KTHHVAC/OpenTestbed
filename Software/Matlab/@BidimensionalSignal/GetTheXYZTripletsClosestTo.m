% algorithm:
%
% - start by finding the closest y signal (i.e., look for the x that is closest to the desired one)
% - then find the closest y in that y signal (i.e., now look for the y that is closest to the desired one given the previously computed closest x)
% - call 'delta' the distance between these closest x, y with the interested point
% - consider then all the y signals that have the associated x not more distant than delta
% - for each of these signals look for that y's that are not more distant than delta among the y's contained in that signal
% - all these couples are the ones containing the 3 candidates, so compute distances with all these points
% - select the closest ones
% - if the number of candidates found in this way is insufficient, then re-do the cycle but multiply delta by two
%
%
% output: the triplets are represented by rows: each row is a triplet
%
function aafXYZTriplets =					...
			GetTheXYZTripletsClosestTo(		...
				tSignal,					...
				fX,							...
				fY,							...
				iHowManyTriplets			)
	%
	% if there is insufficient data then return
	if( tSignal.GetNumberOfSamples() < iHowManyTriplets )
		%
		aafXYZTriplets =							...
			tSignal.GetTheXYZTripletsClosestTo(		...
				fX,									...
				fY,									...
				tSignal.GetNumberOfSamples()		);
		%
		warning('Requested to extract more triplets than what is actually possible to. Returning a smaller set');
		%
	else% select the interesting triplets
		%
		% -----------------------------------------------------
		% perform the first computation of delta
		%
		% find the value of the closest X
		fClosestX = Signal.FindClosestElement( tSignal.tYSignalsIndexes.afTimes, fX );
		%
		% find the index corresponding to this closest X
		iIndexOfClosestX = find( tSignal.tYSignalsIndexes.afTimes == fClosestX );
		%
		% find the corresponding y signal
		iIndexOfYSignalWithClosestX = tSignal.tYSignalsIndexes.afValues(iIndexOfClosestX);
		%
		% then find the closest y inside this signal
		fClosestYGivenX = Signal.FindClosestElement( tSignal.atYSignals{iIndexOfYSignalWithClosestX}.afTimes, fY );
		%
		% thus compute delta
		fDelta = norm( [fX, fY] - [fClosestX, fClosestYGivenX] );
		%
		%
		% -----------------------------------------------------
		% cycle until one finds the desired number of triplets
		%
		% initialization
		aafXYZTriplets = [];
		%
		% cycle
		while( size(aafXYZTriplets, 1) < iHowManyTriplets )
			%
			% get the list of candidate points
			aafCandidateXYZTriplets =					...
				tSignal.GetTheXYZTripletsInsideTheBall(	...
					fX,									...
					fY,									...
					fDelta 								);
			%
			% if the number of candidates is not enough then cycle
			if( size(aafCandidateXYZTriplets, 1) < iHowManyTriplets )
				%
				% increase the radius
				fDelta = fDelta * 2;
				%
			else%
				%
				% compute the distances between the various XYs
				afDistancesBetweenTheXYs = zeros( size(aafCandidateXYZTriplets, 1), 1 ); 
				%
				for iXY = 1:numel(afDistancesBetweenTheXYs);
					%
					afDistancesBetweenTheXYs(iXY) =		...
						norm( [fX, fY] - [aafCandidateXYZTriplets(iXY, 1), aafCandidateXYZTriplets(iXY, 2)] );
					%
				end;%
				%
				% sort them
				[ afSortedDistances, aiSortingIndexes ] =	...
					sort( afDistancesBetweenTheXYs, 'ascend' );
				%
				% get the desired triplets
				aafXYZTriplets = aafCandidateXYZTriplets( aiSortingIndexes(1:iHowManyTriplets), : );
				%
			end;% if there are enough candidates
			%
		end;% while
		%
	end;% if there is enough data to return meaningfully
	%
end % function

